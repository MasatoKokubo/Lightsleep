= Lightsleep 3.1.0 ユーザーガイド

link:UserGuide.asciidoc[English]

[[TOC_]]
=== 目次

1. <<Package,パッケージ>>
2. <<EntityClass,エンティティ･クラスの作成>> +
2-1. <<Entity-Annotation,エンティティ･クラスで使用するアノテーション>> +
2-1-1. <<Entity-Table,@Table>> +
2-1-2. <<Entity-Key,@Key>> +
2-1-3. <<Entity-Column,@Column>> +
2-1-4. <<Entity-ColumnType,@ColumnType>> +
2-1-5. <<Entity-NonColumn,@NonColumn>> +
2-1-6. <<Entity-NonSelect,@NonSelect>> +
2-1-7. <<Entity-NonInsert,@NonInsert>> +
2-1-8. <<Entity-NonUpdate,@NonUpdate>> +
2-1-9. <<Entity-Select,@Select>> +
2-1-10. <<Entity-Insert,@Insert>> +
2-1-11. <<Entity-Update,@Update>> +
2-1-12. <<Entity-XxxxxProperty,@KeyProperty, @ColumnProperty, ... @UpdateProperty>> +
2-2. <<Entity-Interface,エンティティ･クラスで実装するインターフェース>> +
2-2-1. <<Entity-PreInsert,PreInsertインターフェース>> +
2-2-2. <<Entity-Composite,Compositeインターフェース>> +
2-2-3. <<Entity-PreStore,PreStoreインターフェース>> +
2-2-4. <<Entity-PostLoad,PostLoadインターフェース>> +
3. <<lightsleep-properties,lightsleep.propertiesファイルの定義>> +
3-1. <<Logger,ログ･ライブラリ･クラス>> +
3-2. <<Database,データベース･ハンドラ･クラス>> +
3-3. <<ConnectionSupplier,コネクション･サプライヤ･クラス>> +
4. <<Transaction,トランザクション>> +
5. <<ExecuteSQL,SQLの実行>> +
5-1. <<ExecuteSQL-select,SELECT>> +
5-1-1. <<ExecuteSQL-select-1-Expression,SELECT 1行/式条件>> +
5-1-2. <<ExecuteSQL-select-Entity,SELECT 1行/エンティティ条件>> +
5-1-3. <<ExecuteSQL-select-N-Expression,SELECT 複数行/式条件>> +
5-1-4. <<ExecuteSQL-select-Subquery,SELECT サブクエリ条件>> +
5-1-5. <<ExecuteSQL-select-Expression-and,SELECT 式条件/AND>> +
5-1-6. <<ExecuteSQL-select-Expression-or,SELECT 式条件/OR>> +
5-1-7. <<ExecuteSQL-select-Expression-andor,SELECT 式条件/SELECT 式条件/A AND B OR C AND D>> +
5-1-8. <<ExecuteSQL-select-columns,SELECTカラムの選択>> +
5-1-9. <<ExecuteSQL-select-groupBy-having,SELECT GROUP BY, HAVING>> +
5-1-10. <<ExecuteSQL-select-orderBy-offset-limit,SELECT ORDER BY, OFFSET, LIMIT>> +
5-1-11. <<ExecuteSQL-select-forUpdate,SELECT FOR UPDATE>> +
5-1-12. <<ExecuteSQL-select-innerJoin,SELECT 内部結合>> +
5-1-13. <<ExecuteSQL-select-leftJoin,SELECT 左外部結合>> +
5-1-14. <<ExecuteSQL-select-rightJoin,SELECT 右外部結合>> +
5-1-15. <<ExecuteSQL-select-count,SELECT COUNT(*)>> +
5-1-16. <<ExecuteSQL-select-fromSubquery,SELECT FROM句サブクエリ [small fuchsia]#_(v3.1.0~)_#>> +
5-1-17. <<ExecuteSQL-select-union,SELECT UNION, UNION ALL [small fuchsia]#_(v3.1.0~)_#>> +
5-2. <<ExecuteSQL-insert,INSERT>> +
5-2-1. <<ExecuteSQL-insert-1,INSERT 1行>> +
5-2-2. <<ExecuteSQL-insert-N,INSERT 複数行>> +
5-3. <<ExecuteSQL-update,UPDATE>> +
5-3-1. <<ExecuteSQL-update-1,UPDATE 1行>> +
5-3-2. <<ExecuteSQL-update-N,UPDATE 複数行>> +
5-3-3. <<ExecuteSQL-update-Condition,UPDATE 指定条件, カラム選択>> +
5-3-4. <<ExecuteSQL-update-all,UPDATE 全行>> +
5-4. <<ExecuteSQL-delete,DELETE>> +
5-4-1. <<ExecuteSQL-delete-1,DELETE 1行>> +
5-4-2. <<ExecuteSQL-delete-N,DELETE 複数行>> +
5-4-3. <<ExecuteSQL-delete-Condition,DELETE 指定条件>> +
5-4-4. <<ExecuteSQL-delete-all,DELETE 全行>> +
6. <<Expression,式の変換処理>> +
7. <<DateTime,日時型おけるJava型とカラム型の対応>> +
7-1. <<DateTime-DB2,DB2>> +
7-2. <<DateTime-MySQL,MySQL>> +
7-3. <<DateTime-Oracle,Oracle>> +
7-4. <<DateTime-PostgreSQL,PostgreSQL>> +
7-5. <<DateTime-SQLite,SQLite>> +
7-6. <<DateTime-SQLServer,SQL Server>> +

[[Package]]

<<TOC_,目次へ>>

=== 1. パッケージ

以下のパッケージがあります。

.パッケージ一覧
[options="header", width="80%"]
|===
|パッケージ|含まれるクラス/インタフェース
|org.lightsleep                |主に使用するクラス
|org.lightsleep.component      |条件や式などのSQLの構成要素を作成する際に使用するクラス
|org.lightsleep.connection     |各種コネクション･プール･ライブラリを利用してコネクション･ラッパー･クラスを供給するクラス
|org.lightsleep.database       |各種DBMS用のSQLを生成するクラス
|org.lightsleep.database.anchor|JDBC URLに含まれる文字列と*org.lightsleep.database*パッケージのクラスとの対応付けで使用されるクラス
|org.lightsleep.entity         |エンティティ･クラスを作成する際に使用するアノテーション･クラスおよびインタフェース
|org.lightsleep.helper         |ライブラリ内部で使用される補助的なクラス
|org.lightsleep.logger         |各種ロギング･ライブラリを利用してライブラリ内部のログを出力するクラス
|===

[[EntityClass]]

<<TOC_,目次へ>>

=== 2. エンティティ･クラスの作成
データベースのテーブル毎に対応するエンティティ･クラスを作成します。

[[Entity-Annotation]]

==== 2-1. エンティティ･クラスで使用するアノテーション
Lihgtsleepは、エンティティ･クラスまたはオブジェクトを引数とするメソッドでは自動的にテーブルとの関連付けを行いますが、エンティティ･クラスにアノテーションの付与が必要な場合があります。

Lightsleepには、以下のアノテーションがあります。

.アノテーション一覧
[options="header", width="100%"]
|===
|アノテーション型|要素|示す内容|付与する対象
|<<Entity-Table,`@Table`>>
|String value
|関連するテーブル名
|クラス

|<<Entity-Key,`@Key`>>
|`boolean value` (省略値: `true`)
|プライマリ･キーに対応
|フィールド

|<<Entity-Column,`@Column`>>
|String value
|関連するカラムの名前
|フィールド

|<<Entity-ColumnType,`@ColumnType`>>
|Class<?> value
|関連するカラムの型
|フィールド

|<<Entity-NonColumn,`@NonColumn`>>
|`boolean value` (省略値: `true`)
|カラムに関連しない
|フィールド

|<<Entity-NonSelect,`@NonSelect`>>
|`boolean value` (省略値: `true`)
|SELECT SQLに使用しない
|フィールド

|<<Entity-NonInsert,`@NonInsert`>>
|`boolean value` (省略値: `true`)
|INSERT SQLに使用しない
|フィールド

|<<Entity-NonUpdate,`@NonUpdate`>>
|`boolean value` (省略値: `true`)
|UPDATE SQLに使用しない
|フィールド

|<<Entity-Select,`@Select`>>
|String value
|SELECT SQLで使用する式
|フィールド

|<<Entity-Insert,`@Insert`>>
|String value
|INSERT SQLで使用する式
|フィールド

|<<Entity-Update,`@Update`>>
|String value
|UPDATE SQLで使用する式
|フィールド

|<<Entity-XxxxxProperty,`@KeyProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|プライマリ･キーに対応
|クラス

|<<Entity-XxxxxProperty,`@ColumnProperty`>>
|`String property`, +
String column
|関連するカラムの名前
|クラス

|<<Entity-XxxxxProperty,`@ColumnTypeProperty`>>
|`String property`, +
`Class<?> type`
|関連するカラムの型
|クラス

|<<Entity-XxxxxProperty,`@NonColumnProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|カラムに関連しない
|クラス

|<<Entity-XxxxxProperty,`@NonSelectProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|SELECT SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@NonInsertProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|INSERT SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@NonUpdateProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|UPDATE SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@SelectProperty`>>
|`String property`, +
`String expression`
|SELECT SQLで使用する式
|クラス

|<<Entity-XxxxxProperty,`@InsertProperty`>>
|`String property`, +
`String expression`
|INSERT SQLで使用する式
|クラス

|<<Entity-XxxxxProperty,`@UpdateProperty`>>
|`String property`, +
`String expression`
|UPDATE SQLで使用する式
|クラス
|===

[[Entity-Table]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-1. @Table
クラスに関連するデータベース･テーブル名を示します。
テーブル名がクラス名と同じであれば、このアノテーションを指定する必要はありません。

[source,java]
.Java
----
import org.lightsleep.entity.*;

@Table("Contact")
public class Contact1 extends Contact {
   ...
}
----

`@Table("super")` を指定した場合は、スーパークラスのクラス名がテーブル名となります。

[source,java]
.Java
----
@Table("Contact")
public class Person extends PersonBase {

    @Table("super")
     public static class Ex extends Person {
----

[source,groovy]
.Groovy
----
@Table('Contact')
class Person extends PersonBase {

    @Table('super')
     static class Ex extends Person {
----

[[Entity-Key]]

===== 2-1-2. @Key
フィールドに関連するカラムがプライマリー･キーの一部である事を示します。

[source,java]
.Java
----
@Key
public int contactId;
@Key
public short featureIndex;
----

[source,groovy]
.Groovy
----
@Key
int contactId
@Key
short featureIndex
----

[[Entity-Column]]

===== 2-1-3. @Column
フィールドに関連するデータベース･カラム名を示します。
カラム名がフィールド名と同じであれば、このアノテーションを指定する必要がありません。

[source,java]
.Java
----
@Column("firstName")
public String first;
@Column("lastName")
public String last;
----

[source,groovy]
.Groovy
----
@Column('firstName')
String first
@Column('lastName')
String last
----

[[Entity-ColumnType]]

===== 2-1-4. @ColumnType
フィールドに関連するカラムの型を示します。
フィールド型とカラム型が同種類の場合は、指定する必要がありません。
フィールド型が日付型で、カラム型が数値型のように異なる場合に指定します。

[source,java]
.Java
----
@ColumnType(Long.class)
public LocalDate birthday;
----

[source,groovy]
.Groovy
----
@ColumnType(Long)
LocalDate birthday
----

[[Entity-NonColumn]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-5. @NonColumn
フィールドがどのカラムにも関連しない事を示します。

[source,java]
.Java
----
@NonColumn
public List<Phone> phones;
@NonColumn
public List<Address> addresses;
----

[source,groovy]
.Groovy
----
@NonColumn
List<Phone> phones
@NonColumn
List<Address> addresses
----

[[Entity-NonSelect]]

===== 2-1-6. @NonSelect
フィールドに関連するカラムがSELECT SQLで使用されない事を示します。

[source,java]
.Java
----
@NonSelect
public LocalDateTime createdTime;
@NonSelect
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@NonSelect
LocalDateTime createdTime
@NonSelect
LocalDateTime updatedTime
----

[[Entity-NonInsert]]

===== 2-1-7. @NonInsert
フィールドに関連するカラムがINSERT SQLで使用されない事を示します。

[source,java]
.Java
----
@NonInsert
public LocalDateTime createdTime;
@NonInsert
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@NonInsert
LocalDateTime createdTime
@NonInsert
LocalDateTime updatedTime
----

[[Entity-NonUpdate]]

===== 2-1-8. @NonUpdate
フィールドに関連するカラムがUPDATE SQLで使用されない事を示します。

[source,java]
.Java
----
@NonUpdate
public LocalDateTime createdTime;
----

[source,groovy]
.Groovy
----
@NonUpdate
LocalDateTime createdTime
----

[[Entity-Select]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-9. @Select
SELECT SQLのカラム名の代わりの式を指定します。

[source,java]
.Java
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
public String fullName;
----

[source,groovy]
.Groovy
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
String fullName
----

[[Entity-Insert]]

===== 2-1-10. @Insert
INSERT SQLの挿入値の式を示します。
このアノテーションが指定された場合、フィールドの値は使用されません。

[source,java]
.Java
----
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime createdTime;
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@Insert('CURRENT_TIMESTAMP')
LocalDateTime createdTime
@Insert('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-Update]]

===== 2-1-11. @Update
UPDATE SQLの更新値の式を示します。
このアノテーションが指定された場合、フィールドの値は使用されません。

[source,java]
.Java
----
@Update("{updateCount}+1")
public int updateCount;
@Update("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@Update('{updateCount}+1')
int updateCount
@Update('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-XxxxxProperty]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-12. @KeyProperty, @ColumnProperty, ... @UpdateProperty
これらのアノテーションは、スーパークラスで定義されているフィールドに対して指定する場合に使用します。
指定された内容はサブクラスにも影響しますが、サブクラスでの指定が優先されます。
`value=false`, `column=""`, `type=Void.class`, `expression=""` を指定すると、スーパークラスでの指定が打ち消されます。

[source,java]
.Java
----
@KeyProperty(property="contactId")
@KeyProperty(property="featureIndex")
public class ContactFeature extends ContactFeatureKey {
----

[source,groovy]
.Groovy
----
@KeyProperties([
    @KeyProperty(property='contactId'),
    @KeyProperty(property='featureIndex')
])
class ContactFeature extends ContactFeatureKey {
----

[[Entity-Interface]]

=== 2-2. エンティティ･クラスで実装するインターフェース

[[Entity-PreInsert]]

<<TOC_,目次へ>>

==== 2-2-1. PreInsertインターフェース
エンティティ･クラスがこのインターフェースを実装している場合、`Sql` クラスの `insert` メソッドで、INSERT SQL実行前に `preInsert` メソッドがコールされます。
`preInsert` メソッドでは、プライマリー･キーの採番の実装等を行います。

[source,java]
.Java
----
public abstract class Common implements PreInsert {
    @Key
    public int id;
        ...

    @Override
    public int preInsert(ConnectionWrapper conn) {
        id = Numbering.getNewId(conn, getClass());
        return 0;
    }
}
----

[[Entity-Composite]]

<<TOC_,目次へ>>

==== 2-2-2. Compositeインターフェース
エンティティ･クラスがこのインターフェースを実装している場合、`Sql` クラスの `select`, `insert`, `update` または `delete` メソッドで、各 SQLの実行後にエンティティ･クラスの `postSelect`, `postInsert`, `postUpdate` または `postDelete` メソッドがコールされます。
ただし `update`, `delete` メソッドで、引数にエンティティがない場合は、コールされません。
エンティティが他のエンティティを内包する場合、このインターフェースを実装する事で、内包するエンティティへの SQL 処理を連動して行う事ができるようになります。

[source,java]
.Java
----
@Table("super")
public class ContactComposite extends Contact implements Composite {
    @NonColumn
    public final List<Phone> phones = new ArrayList<>();

    @Override
    public void postSelect(ConnectionWrapper conn) {
        if (id != 0) {
            new Sql<>(Phone.class)
                .where("{contactId}={}", id)
                .orderBy("{phoneNumber}")
                .connection(conn)
                .select(phones::add);
        }
    }

    @Override
    public int postInsert(ConnectionWrapper conn) {
        phones.forEach(phone -> phone.contactId = id);
        int count = new Sql<>(Phone.class)
            .insert(phones);
            .connection(conn)
        return count;
    }

    @Override
    public int postUpdate(ConnectionWrapper conn) {
        List<Integer> phoneIds = phones.stream()
            .map(phone -> phone.id)
            .filter(id -> id != 0)
            .collect(Collectors.toList());

        // Delete phones
        int count += new Sql<>(Phone.class)
            .where("{contactId}={}", id)
            .doIf(phoneIds.size() > 0,
                sql -> sql.and("{id} NOT IN {}", phoneIds)
            )
            .connection(conn)
            .delete();

        // Uptete phones
        count += new Sql<>(Phone.class)
            .connection(conn)
            .update(phones.stream()
                .filter(phone -> phone.id != 0)
                .collect(Collectors.toList()));

        // Insert phones
        count += new Sql<>(Phone.class)
            .connection(conn)
            .insert(phones.stream()
                .filter(phone -> phone.id == 0)
                .collect(Collectors.toList()));

        return count;
    }
 +
    @Override
    public int postDelete(ConnectionWrapper conn) {
        int count = new Sql<>(Phone.class)
            .connection(conn)
            .where("{contactId}={}", id)
            .delete();
        return count;
    }
----

[[Entity-PreStore]]

<<TOC_,目次へ>>

==== 2-2-3. PreStoreインターフェース
エンティティ･クラスがこのインターフェースを実装している場合、`Sql` クラスの `insert` および `update` メソッドで、各SQLが実行される前にエンティティ･クラスの `preStore` メソッドがコールされます。

[[Entity-PostLoad]]

==== 2-2-4. PostLoadインターフェース
エンティティ･クラスがこのインターフェースを実装している場合、`Sql` クラスの `select` メソッドでSELECT SQLが実行されエンティティにデータベースから取得した値が設定された後にエンティティ･クラスの `postLoad` メソッドがコールされます。

[source,java]
.Java
----
import org.lightsleep.entity.*;

public class Contact implements PreStore, PostLoad {

    @Column("phone")
    public String[] phones_

    @NonColumn
    public final List<String> phones = new ArrayList<>();

    public void preStore() {
        phones_ = phones.toArray(new String[phones.size()]);
    }

    public void postLoad() {
        phones.clear();
        Arrays.stream(phones_).forEach(phones::add);
    }
----

[[lightsleep-properties]]

<<TOC_,目次へ>>

[[lightsleep-properties]]
=== 3. lightsleep.propertiesの定義

lightsleep.propertiesは、Lightsleepが参照するプロパティ･ファイルで、以下の内容を指定できます。 +
*(バージョン2.0.0まで存在した `Database` プロパティは、バージョン2.1.0で削除されました。データベース･ハンドラは、JDBC URLから自動的に決定されます。)*

[options="header", width="80%"]
|===
|プロパティ名|指定する内容|デフォルト値
|`<<Logger,Logger>>`
|ログ出力クラス
|`Std$Out$Info`

|`<<ConnectionSupplier,ConnectionSupplier>>`
|コネクション･サプライヤ･クラス
|`Jdbc`

|`url`                   |JDBC URL|なし
|`urls`                  |JDBC URL(複数)|なし
|`dataSource`            |`Jndi` を使用した場合のデータソース名|なし
|`dataSources`           |`Jndi` を使用した場合のデータソース名(複数)|なし
|`maxStringLiteralLength`|SQLが生成される時の文字列リテラルの最大長|128
|`maxBinaryLiteralLength`|SQLが生成される時のバイナリ列リテラルの最大長|128
|`maxLogStringLength`    |ログに出力する文字列値の最大長|200
|`maxLogByteArrayLength` |ログに出力するバイト配列の最大要素数|200
|`maxLogArrayLength`     |ログに出力する配列の最大要素数|100
|`maxLogMapSize`         |ログに出力するマップの最大要素数|100

|`connectionLogFormat` +
[small fuchsia]#_(v2.2.0~)_#
|`ConnectionSupplier` のログ出力フォーマット +
*文字列の置換:* +
*{0}*: データベース･ハンドラのクラス名 +
*{1}*: コネクション･サプライヤのクラス名 +
*{2}*: 接続先JDBC URL
|`[{0}/{1}]`
|===

`lightsleep.properties` ファイルは、クラス･パスのいずれかに置いてください。あるいはシステム･プロパティ `lightsleep.resource` でファイル･パスを指定する事もできます。*(java -Dlightsleep.resource=...)* +
上記以外にもコネクション･プール･ライブラリが使用するプロパティを定義します。

lightsleep.propertiesの例: +

[source,properties]
.lightsleep.properties
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
url         = jdbc:postgresql://postgresqlserver/example
user        = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

`urls` プロパティにカンマ区切りで複数のJDBC URLを指定できます。[small fuchsia]#_(v2.1.0~)_# +
1つのプロパティを複数行で定義する場合は、最後の行以外の行末にバックスラッシュ(`\`)を付加します。 +
`urls` を指定した場合は、`url` の指定は無効になります。

[source,properties]
.lightsleep.properties - 複数のJDBC URLを指定する場合
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
urls        = jdbc:postgresql://postgresqlserver/example1,\
              jdbc:postgresql://postgresqlserver/example2
user        = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

JDBC URL毎に異なるDBMSのURLを指定できます。JDBC URL毎にユーザー、パスワードが異なる場合は、URL内で指定してください。

[source,properties]
.lightsleep.properties - 複数のDBMSを使用する場合(URL内でユーザーとパスワードを指定)
----
Logger = Log4j2
ConnectionSupplier = Dbcp
urls = \
    jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    jdbc:mysql://mysql57/example?user=example&password=_example_,\
    jdbc:oracle:thin:example/_example_@oracle121:1521:example,\
    jdbc:postgresql://postgresql101/example?user=example&password=_example_,\
    jdbc:sqlite:C:/sqlite/example,\
    jdbc:sqlserver://sqlserver13;database=example;user=example;password=_example_,\

initialSize = 10
maxTotal    = 100
----

URL毎にコネクション･サプライヤを指定する場合は、URLの先頭の `[]` 内に記述します。[small fuchsia]#_(v2.1.0~)_# +
この形式の指定は、`ConnectionSupplier` プロパティの指定よりも優先されます。 +
`username`, `jdbcUrl` プロパティは、`user`, `url` プロパティで指定する事ができますが、それら以外はコネクション･プール･ライブラリ固有のプロパティ名で指定してください。

[source,properties]
.lightsleep.properties - URL毎にコネクション･サプライヤを指定する場合
----
Logger = Log4j2
urls = \
    [  Jdbc  ]jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    [  C3p0  ]jdbc:mysql://mysql57/example?user=example&password=_example_,\
    [  Dbcp  ]jdbc:oracle:thin:example/_example_@oracle121:1521:example,\
    [HikariCP]jdbc:postgresql://postgresql101/example?user=example&password=_example_,\
    [TomcatCP]jdbc:sqlite:C:/sqlite/example,\
    [  Jdbc  ]jdbc:sqlserver://sqlserver13;database=example;user=example;password=_example_,\

# Dbcp, HikariCP, TomcatCP
initialSize = 10

# Dbcp
maxTotal    = 10

# TomcatCP
maxActive   = 10

# HikariCP
minimumIdle     = 10
maximumPoolSize = 10
----

[[Logger]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-1. ログ･ライブラリ･クラスの指定

Loggerプロパティの値は以下から選択してください。

[options="header", width="80%"]
|===
|指定値|ログ･ライブラリなど|ログ･レベル|ログ･ライブラリが使用する定義ファイル
|`Jdk`          |Java Runtime    |－   |logging.properties
|`Log4j`        |Log4j           |－   |log4j.propertiesまたはlog4j.xml
|`Log4j2`       |Log4j 2         |－   |log4j2.xml
|`SLF4J`        |SLF4J           |－   |対象とするログ･ライブラリ実装に依存
|`Std$Out$Trace`|System.outに出力|trace|－
|`Std$Out$Debug`|_同上_          |debug|－
|`Std$Out$Info` |_同上_          |info |－
|`Std$Out$Warn` |_同上_          |warn |－
|`Std$Out$Error`|_同上_          |error|－
|`Std$Out$Fatal`|_同上_          |fatal|－
|`Std$Err$Trace`|System.errに出力|trace|－
|`Std$Err$Debug`|_同上_          |debug|－
|`Std$Err$Info` |_同上_          |info |－
|`Std$Err$Warn` |_同上_          |warn |－
|`Std$Err$Error`|_同上_          |error|－
|`Std$Err$Fatal`|_同上_          |fatal|－
|===

指定がない場合は、`Std$Out$Info` が選択されます。

[[Database]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-2. データベース･ハンドラ･クラス

データベース･ハンドラ･クラスは、`url` または `urls` プロパティで指定されたJDBC URLの内容から自動的に選択されます。[small fuchsia]#_(v2.1.0~)_#

[options="header", width="60%"]
|===
|JDBC URLに含まれる文字列|選択されるクラス|対応するDBMS
|`db2`       |`DB2`       |link:https://www.ibm.com/us-en/marketplace/db2-express-c[DB2]
|`mysql`     |`MySQL`     |link:https://www.mysql.com/[MySQL]
|`oracle`    |`Oracle`    |link:https://www.oracle.com/database/index.html[Oracle Database]
|`postgresql`|`PostgreSQL`|link:https://www.postgresql.org/[PostgreSQL]
|`sqlite`    |`SQLite`    |link:https://sqlite.org/index.html[SQLite]
|`sqlserver` |`SQLServer` |link:https://www.microsoft.com/ja-jp/sql-server/sql-server-2016[Microsoft SQL Server]
|===

JDBC URLに上記の文字列のいずれもが含まれていない場合、`Standard` クラスが選択されます。

[[ConnectionSupplier]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-3. コネクションを供給するクラスの指定

ConnectionSupplierプロパティの値は以下から選択してください。JDBC URLの先頭の `[]` 内で指定する事もできます。

[options="header", width="60%"]
|===
|指定値|対応するコネクション･プール･ライブラリ
|`C3p0`    |link:http://www.mchange.com/projects/c3p0/[c3p0]
|`Dbcp`    |link:https://commons.apache.org/proper/commons-dbcp/[Apache Commons DBCP]
|`HikariCP`|link:http://brettwooldridge.github.io/HikariCP/[HikariCP]
|`TomcatCP`|link:http://tomcat.apache.org/tomcat-8.5-doc/jdbc-pool.html[Tomcat JDBC Connection Pool]
|`Jndi`    |Java Naming and Directory Interface (JNDI) (link:http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html[Tomcatの場合])
|`Jdbc`    |`DriverManager#getConnection(String url, Properties info)` メソッド
|===

`C3p0`, `Dbcp 2`, `HikariCP`, `TomcatCP` クラスは、それぞれ対応するコネクション･プール･ライブラリを使用してデータベース･コネクションを取得します。 +
`Jndi` クラスは、JNDI (Java Naming and Directory Interface)を使用して取得したデータソース(`javax.sql.DataSource`)からデータベース･コネクションを取得します。 +
`Jdbc` クラスは、`java.sql.DriverManager.getConnection` メソッドを使用してデータベース･コネクションを取得します。 +
コネクション･プール･ライブラリが必要する情報もlightsleep.propertiesファイルに定義してください。
以下のlightsleep.propertiesの定義例のConnectionSupplierより下(url ~)は、コネクション･プール･ライブラリに渡す内容です。

[source,properties]
.lightsleep.properties - Jdbc
----
ConnectionSupplier = Jdbc
url      = jdbc:db2://db2-11:50000/example
user     = example
password = _example_
----

[source,properties]
.lightsleep.properties - C3p0
----
ConnectionSupplier = C3p0
url      = jdbc:mysql://mysql57/example
user     = example
password = _example_
----

[source,properties]
.c3p0.properties
----
c3p0.initialPoolSize = 20
c3p0.minPoolSize     = 10
c3p0.maxPoolSize     = 30
----

[source,properties]
.lightsleep.properties - Dbcp
----
ConnectionSupplier = Dbcp
url         = jdbc:oracle:thin:@oracle121:1521:example
user        = example
  または
username    = example
password    = _example_
initialSize = 20
maxTotal    = 30
----

[source,properties]
.lightsleep.properties - HikariCP
----
ConnectionSupplier = HikariCP
url             = jdbc:postgresql://postgres96/example
  または
jdbcUrl         = jdbc:postgresql://postgres96/example
user            = example
  または
username        = example
password        = _example_
minimumIdle     = 10
maximumPoolSize = 30
----

[source,properties]
.lightsleep.properties - TomcatCP
----
ConnectionSupplier = TomcatCP
url         = jdbc:sqlserver://sqlserver13;database=example
user        = example
  または
username    = example
password    = _example_
initialSize = 20
maxActive   = 30
----

[source,properties]
.lightsleep.properties - Jndi
----
ConnectionSupplier = Jndi
dataSource         = jdbc/example
  または
dataSource         = example
----

<<TOC_,目次へ>>

=== 4. トランザクション

`Transaction.execute` メソッドの実行が1つのトランザクションの実行に相当します。
トランザクションの内容を引数 `transaction`(ラムダ式) で定義してください。
ラムダ式は、`Transaction.executeBody` メソッドの内容に相当し、このメソッドの引数は、`ConnectionWrapper` です。

[source,java]
.Java
----
Contact contact = new Contact(1, "Akane", "Apple");

Transaction.execute(conn -> {
    // トランザクション開始
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
   ...
    // トランザクション終了
});
----

[source,groovy]
.Groovy
----
def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute {
    // トランザクション開始
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // トランザクション終了
}
----

複数のJDBC URLを `lightsleep.properties` に定義した場合は、どのURLに対してトランザクションの実行を行うかを指定する必要があります。 `ConnectionSupplier.find` メソッドは、引数の文字列配列のすべてが含まれるJDBC URLを検索します。
複数見つかった場合または見つからない場合は例外がスローされます。

[source,java]
.Java
----
public static final ConnectionSupplier supplier1 = ConnectionSupplier.find("example1");
    ...

Contact contact = new Contact(1, "Akane", "Apple");

Transaction.execute(supplier1, conn -> {
    // トランザクション開始
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
   ...
    // トランザクション終了
});
----

[source,groovy]
.Groovy
----
static final supplier1 = ConnectionSupplier.find('example1')
    ...

def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute(supplier1) {
    // トランザクション開始
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // トランザクション終了
}
----

トランザクション中に例外がスローされた場合は、`Transaction.rollback` メソッドが実行され、
そうでなければ `Transaction.commit` メソッドが実行されます。

[[ExecuteSQL]]

<<TOC_,目次へ>>

=== 5. SQLの実行
SQLの実行は、`Sql` クラスの各種メソッドを使用し、`Transaction.execute` メソッドの引数のラムダ式内に定義します。

[[ExecuteSQL-select]]

==== 5-1. SELECT

[[ExecuteSQL-select-1-Expression]]

==== 5-1-1. SELECT 1行/式条件

[source,java]
.Java
----
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-Entity]]

<<TOC_,目次へ>>

==== 5-1-2. SELECT 1行/エンティティ条件

[source,java]
.Java
----
Contact contact = new Contact();
contact.id = 1;
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where(contact)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
def contact = new Contact()
contact.id = 1
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where(contact)
        .connection(it)
        .select()
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-N-Expression]]

<<TOC_,目次へ>>

==== 5-1-3. SELECT 複数行/式条件

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it})
}
----


[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple'
----

[[ExecuteSQL-select-Subquery]]

<<TOC_,目次へ>>

==== 5-1-4. SELECT サブクエリ条件

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .where("EXISTS",
            new Sql<>(Phone.class, "P")
                .where("{P.contactId}={C.id}")
        )
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .where('EXISTS',
            new Sql<>(Phone, 'P')
                .where('{P.contactId}={C.id}')
        )
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime
  FROM Contact C
  WHERE EXISTS (SELECT * FROM Phone P WHERE P.contactId=C.id)
----

[[ExecuteSQL-select-Expression-and]]

<<TOC_,目次へ>>

==== 5-1-5. SELECT 式条件/AND

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .and  ("{firstName}={}", "Akane")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .and  ('{firstName}={}', 'Akane')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane'
----

[[ExecuteSQL-select-Expression-or]]

<<TOC_,目次へ>>

==== 5-1-6. SELECT 式条件/OR

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .or   ("{lastName}={}", "Orange")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .or   ('{lastName}={}', 'Orange')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' OR lastName='Orange'
----

[[ExecuteSQL-select-Expression-andor]]

<<TOC_,目次へ>>

==== 5-1-7. SELECT 式条件/A AND B OR C AND D

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition
            .of ("{lastName}={}", "Apple")
            .and("{firstName}={}", "Akane")
        )
        .or(Condition
            .of ("{lastName}={}", "Orange")
            .and("{firstName}={}", "Setoka")
        )
        .connection(conn)
        .select(contacts::add)
);
----
[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute(conn ->
    new Sql<>(Contact)
        .where(Condition
            .of ('{lastName}={}', 'Apple')
            .and('{firstName}={}', 'Akane')
        )
        .or(Condition
            .of ('{lastName}={}', 'Orange')
            .and('{firstName}={}', 'Setoka')
        )
        .connection(it)
        .select({contacts << it})
);
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane' OR lastName='Orange' AND firstName='Setoka'
----

[[ExecuteSQL-select-columns]]

<<TOC_,目次へ>>

==== 5-1-8. SELECTカラムの選択

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .columns("lastName", "firstName")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .columns('lastName', 'firstName')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT firstName, lastName FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-groupBy-having]]

<<TOC_,目次へ>>

==== 5-1-9. SELECT GROUP BY, HAVING

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .columns("lastName")
        .groupBy("{lastName}")
        .having("COUNT({lastName})>=2")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .columns('lastName')
        .groupBy('{lastName}')
        .having('COUNT({lastName})>=2')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT MIN(C.lastName) C_lastName FROM Contact C GROUP BY C.lastName HAVING COUNT(C.lastName)>=2
----

[[ExecuteSQL-select-orderBy-offset-limit]]

<<TOC_,目次へ>>

==== 5-1-10. SELECT ORDER BY, OFFSET, LIMIT

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .orderBy("{lastName}")
        .orderBy("{firstName}")
        .orderBy("{id}")
        .offset(10).limit(5)
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .orderBy('{lastName}')
        .orderBy('{firstName}')
        .orderBy('{id}')
        .offset(10).limit(5)
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL - DB2, MySQL, PostgreSQL, SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
  LIMIT 5 OFFSET 10
----

[source,sql]
.生成されるSQL - Oracle, SQLServer (取得時に行をスキップする)
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
----

[[ExecuteSQL-select-forUpdate]]

<<TOC_,目次へ>>

==== 5-1-11. SELECT FOR UPDATE

[source,java]
.Java
----
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .forUpdate()
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .forUpdate()
        .connection(it)
        .select()
}
----

[source,sql]
.生成されるSQL - DB2
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE WITH RS
----

[source,sql]
.生成されるSQL - MySQL, Oracle, PostgreSQL, SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE
----

[source,sql]
.生成されるSQL - SQLite
----
-- SQLiteでは、FOR UPDATEをサポートしていないのでUnsupportedOperationExceptionがスローされます。
----

[source,sql]
.生成されるSQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WITH (ROWLOCK,UPDLOCK) WHERE id=1
----

[[ExecuteSQL-select-innerJoin]]

<<TOC_,目次へ>>

==== 5-1-12. SELECT 内部結合

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .innerJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.id}={}", 1)
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .innerJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.id}={}', 1)
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  INNER JOIN Phone P ON P.contactId=C.id
  WHERE C.id=1
----

[[ExecuteSQL-select-leftJoin]]

<<TOC_,目次へ>>

==== 5-1-13. SELECT 左外部結合

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .leftJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.lastName}={}", "Apple")
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .leftJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  LEFT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE C.lastName='Apple'
----

[[ExecuteSQL-select-rightJoin]]

<<TOC_,目次へ>>

==== 5-1-14. SELECT 右外部結合

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .rightJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{P.label}={}", "Main")
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .rightJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{P.label}={}', 'Main')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.生成されるSQL
----
-- SQLiteでは、RIGHT OUTER JOINが未サポートのため、例外がスローされます。
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  RIGHT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE P.label='Main'
----

[[ExecuteSQL-select-count]]

<<TOC_,目次へ>>

==== 5-1-15. SELECT COUNT(*)

[source,java]
.Java
----
int[] rowCount = new int[1];
Transaction.execute(conn ->
    count[0] = new Sql<>(Contact.class)
        .where("lastName={}", "Apple")
        .connection(conn)
        .selectCount()
);
----

[source,groovy]
.Groovy
----
def rowCount = 0
Transaction.execute {
    count = new Sql<>(Contact)
        .where('lastName={}', 'Apple')
        .connection(it)
        .selectCount()
}
----

[source,sql]
.生成されるSQL
----
SELECT COUNT(*) FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-fromSubquery]]

<<TOC_,目次へ>>

==== 5-1-16. SELECT FROM句サブクエリ

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn -> {
    Class<? extends Contact.Ex> contactClass = Contact.Ex.targetClass(conn.getDatabase());
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where("{fullName}={}", "Akane Apple")
        .orderBy("{fullName}")
        .connection(conn)
        .select(contacts::add);
});
----

[source,groovy]
.Groovy
----
def contacts = []
Transaction.execute {
    def contactClass = Contact.Ex.targetClass(conn.database)
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where('{fullName}={}', 'Akane Apple')
        .orderBy('{fullName}')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, fullName
  FROM (
    SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, firstName||' '||lastName fullName FROM Contact
  ) Contact
  WHERE fullName='Akane Apple' ORDER BY fullName ASC
----

[[ExecuteSQL-select-union]]

<<TOC_,目次へ>>

==== 5-1-17. SELECT UNION, UNION ALL

[source,java]
.Java
----
List<ContactFeature> features = new ArrayList<>();
String targetFirstName = "Setoka";
String targetLastName = "Orange";
Transaction.execute(conn -> {
    new Sql<>(ContactFeature.class, "F")
        .columns(ContactFeature.class)
        .unionAll(new Sql<>(Address.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Email.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Phone.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Url.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .orderBy("{F_label}")
        .connection(conn)
        .select(features::add);
});
----

[source,groovy]
.Groovy
----
def features = []
def targetFirstName = 'Setoka'
def targetLastName = 'Orange'
Transaction.execute {
    new Sql<>(ContactFeature, 'F')
        .columns(ContactFeature)
        .unionAll(new Sql<>(Address)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Email)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Phone)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Url)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .orderBy('{F_label}')
        .connection(it)
        .select({features << it})
}
----

[source,sql]
.生成されるSQL
----
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Address F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Email F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Phone F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Url F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
ORDER BY F_label ASC
----

[[ExecuteSQL-insert]]

<<TOC_,目次へ>>

==== 5-2. INSERT

[[ExecuteSQL-insert-1]]

==== 5-2-1. INSERT 1行

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .connection(it)
        .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
}
----

[source,sql]
.生成されるSQL - DB2, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact
  (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', DATE'2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.生成されるSQL - SQLite
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', '2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.生成されるSQL - SQLServer
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', CAST('2001-01-01' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-insert-N]]

<<TOC_,目次へ>>

==== 5-2-2. INSERT 複数行

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(Arrays.asList(
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ))
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .connection(it)
        .insert([
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ])
}
----

[source,sql]
.生成されるSQL - DB2, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', DATE'2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', DATE'2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.生成されるSQL - SQLite
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', '2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', '2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.生成されるSQL - SQLServer
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', CAST('2001-01-02' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', CAST('2001-01-03' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-update]]

<<TOC_,目次へ>>

==== 5-3. UPDATE

[[ExecuteSQL-update-1]]

==== 5-3-1. UPDATE 1行

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact -> {
            contact.firstName = "Akiyo";
            new Sql<>(Contact.class)
                .connection(conn)
                .update(contact);
        })
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {Contact contact ->
            contact.firstName = 'Akiyo'
            new Sql<>(Contact)
                .connection(it)
                .update(contact)
        }
}
----

[source,sql]
.生成されるSQL - DB2, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.生成されるSQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.生成されるSQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[[ExecuteSQL-update-N]]

<<TOC_,目次へ>>

==== 5-3-2. UPDATE 複数行

[source,java]
.Java
----
Transaction.execute(conn -> {
    List<Contact> contacts = new ArrayList<>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contact -> {
            contact.lastName = "Apfel";
            contacts.add(contact);
        });
    new Sql<>(Contact.class)
        .connection(conn)
        .update(contacts);
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({Contact contact ->
            contact.lastName = 'Apfel'
            contacts << contact
        })
    new Sql<>(Contact)
        .connection(it)
        .update(contacts)
}
----

[source,sql]
.生成されるSQL - DB2, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=DATE'2001-01-02', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday=DATE'2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.生成されるSQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday='2001-01-02', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday='2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.生成されるSQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=CAST('2001-01-02' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday=CAST('2001-01-03' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[[ExecuteSQL-update-Condition]]

<<TOC_,目次へ>>

==== 5-3-3. UPDATE 指定条件, カラム選択

[source,java]
.Java
----
Contact contact = new Contact();
contact.lastName = "Pomme";
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apfel")
        .columns("lastName")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy
----
def contact = new Contact()
contact.lastName = 'Pomme'
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apfel')
        .columns('lastName')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.生成されるSQL
----
UPDATE Contact SET lastName='Pomme' WHERE lastName='Apfel'
----

[[ExecuteSQL-update-all]]

<<TOC_,目次へ>>

==== 5-3-4. UPDATE 全行

[source,java]
.Java
----
Contact contact = new Contact();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition.ALL)
        .columns("birthday")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy
----
def contact = new Contact()
Transaction.execute {
    new Sql<>(Contact)
        .where(Condition.ALL)
        .columns('birthday')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.生成されるSQL
----
UPDATE Contact SET birthday=NULL
----

[[ExecuteSQL-delete]]

<<TOC_,目次へ>>

==== 5-4. DELETE

[[ExecuteSQL-delete-1]]

==== 5-4-1. DELETE 1行

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact ->
            new Sql<>(Contact.class)
                .connection(conn)
                .delete(contact))
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {contact ->
            new Sql<>(Contact)
                .connection(it)
                .delete(contact)
        }
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
DELETE FROM Contact WHERE id=1
----

[[ExecuteSQL-delete-N]]

<<TOC_,目次へ>>

==== 5-4-2. DELETE 複数行

[source,java]
.Java
----
Transaction.execute(conn -> {
    List<Contact> contacts = new ArrayList<>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Pomme")
        .connection(conn)
        .select(contacts::add);
    new Sql<>(Contact.class)
        .connection(conn)
        .delete(contacts);
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Pomme')
        .connection(it)
        .select({contacts << it})
    new Sql<>(Contact)
        .connection(it)
        .delete(contacts)
}
----

[source,sql]
.生成されるSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Pomme'
DELETE FROM Contact WHERE id=2
DELETE FROM Contact WHERE id=3
----

[[ExecuteSQL-delete-Condition]]

<<TOC_,目次へ>>

==== 5-4-3. DELETE 指定条件

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Orange")
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Orange')
        .connection(it)
        .delete()
}
----

[source,sql]
.生成されるSQL
----
DELETE FROM Contact WHERE lastName='Orange'
----

[[ExecuteSQL-delete-all]]

<<TOC_,目次へ>>

==== 5-4-4. DELETE 全行

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Phone.class)
        .where(Condition.ALL)
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Phone)
        .where(Condition.ALL)
        .connection(it)
        .delete()
}
----

[source,sql]
.生成されるSQL
----
DELETE FROM Phone
----

[[Expression]]

<<TOC_,目次へ>>

=== 6. 式の変換処理

SQL を生成する時に、以下の文字列を式として評価し、変換処理を行います。

* `@Select`, `@Insert`, `@Update` アノテーションの値

* `@SelectProperty`, `@InsertProperty`, `@UpdateProperty` アノテーションの `expression` の値

* `Sql` クラスの以下のメソッドの引数
** `where(String content, Object... arguments)`
** `where(String content, Sql<SE> subSql)`
** `where(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<SE> subSql)`
** `and(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<SE> subSql)`
** `or(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `groupBy(String content, Object... arguments)`
** `having(String content, Object... arguments)`
** `having(String content, Sql<SE> subSql)`
** `having(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `orderBy(String content, Object... arguments)`

* `Condition` インターフェースの以下のメソッドの引数
** `of(String content, Object... arguments)`
** `of(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `of(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `and(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `or(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#

* `Expression` クラスの以下のコンストラクタの引数
** `Expression(String content, Object... arguments)`

式の変換には以下があります。

[options="header", width="80%"]
|===
|書式|変換内容
|`{}`     |出現順に `arguments` の要素
|`{xxx}`  |`xxx` プロパティに関連するカラム名
|`{A.xxx}`|`"A."` + `xxx` プロパティに関連するカラム名(`A` はテーブル別名)
|`{A_xxx}`|テーブル別名 `A` と `xxx` プロパティに関連するカラム別名
|`{#xxx}` |`Sql` オブジェクトに設定されたエンティティ(または `Sql#insert`, `Sql#update` メソッドのエンティティ引数)の `xxx` プロパティの値
|===

[[DateTime]]

<<TOC_,目次へ>>


=== 7. 日時型おけるJava型とカラム型の対応

[[DateTime-DB2]]

===== 7.1 DB2

[options="header", width="65%", cols=",^,^,^,"]
|===
|                          |`DATE`|`TIME`|`TIMESTAMP(9)`|
|`java.util.Date`          |✓     |      |              |
|`java.sql.Date`           |✓     |      |              |
|`java.sql.Time`           |      |✓ (秒)|              |
|`java.sql.Timestamp`      |✓     |      |✓ (10^9^ 秒)  |
|`java.time.LocalDate`     |      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (秒)|              |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |      |✓ (10^9^ 秒)  |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |      |              |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-MySQL]]

===== 7.2 MySQL

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME`      |`DATETIME`  |`TIMESTAMP` |
|`java.util.Date`          |✓     |            |            |            |
|`java.sql.Date`           |✓     |            |            |            |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|            |            |
|`java.sql.Timestamp`      |✓     |            |✓ (10^6^ 秒)|✓ (10^6^ 秒)|
|`java.time.LocalDate`     |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^6^ 秒)|            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^6^ 秒)|✓ (10^6^ 秒)|[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-Oracle]]

===== 7.3 Oracle

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIMESTAMP(9)`|`TIMESTAMP(9) WITH TIME ZONE`|`TIMESTAMP(9) WITH LOCAL TIME ZONE`|
|`java.util.Date`          |✓     |              |                             |                                   |
|`java.sql.Date`           |✓     |              |                             |                                   |
|`java.sql.Time`           |✓ (秒)|              |                             |                                   |
|`java.sql.Timestamp`      |✓ (秒)|✓ (10^9^ 秒)  |                             |✓ (10^9^ 秒)                       |
|`java.time.LocalDate`     |✓ (秒)|              |                             |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |✓ (秒)|              |                             |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |✓ (秒)|✓ (10^9^ 秒)  |                             |✓ (10^9^ 秒)                       |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-PostgreSQL]]

===== 7.4 PostgreSQL

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(6)`   |`TIMESTAMP(6)`|`TIMESTAMP(6) WITH TIME ZONE`|
|`java.util.Date`          |✓     |            |              |                             |
|`java.sql.Date`           |✓     |            |              |                             |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|              |                             |
|`java.sql.Timestamp`      |✓     |            |✓ (10^6^ 秒)  |                             |
|`java.time.LocalDate`     |      |            |              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^6^ 秒)|              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^6^ 秒)  |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |              |✓ (10^6^ 秒)                 |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |              |✓ (10^6^ 秒)                 |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-SQLite]]

===== 7.5 SQLite

[options="header", width="40%", cols=",^,"]
|===
|                          |`DATE`, `TIME`, `DATETIME`, `TEXT`|
|`java.util.Date`          |✓                                 |
|`java.sql.Date`           |✓                                 |
|`java.sql.Time`           |✓ (10^3^ 秒)                      |
|`java.sql.Timestamp`      |✓ (10^9^ 秒)                      |
|`java.time.LocalDate`     |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-SQLServer]]

===== 7.6 SQL Server

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(7)`   |`DATETIME2(7)`|`DATETIMEOFFSET(7)`|
|`java.util.Date`          |✓     |            |              |                   |
|`java.sql.Date`           |✓     |            |              |                   |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|              |                   |
|`java.sql.Timestamp`      |✓     |            |✓ (10^7^ 秒)  |                   |
|`java.time.LocalDate`     |      |            |              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^3^ 秒)|              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^7^ 秒)  |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |              |✓ (10^7^ 秒)       |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |              |✓ (10^7^ 秒)       |[small fuchsia]#_v3.0.0~_#
|===

<<TOC_,目次へ>>

[gray]#_(C) 2015 Masato Kokubo_#
