= Lightsleep [.small]#4.0.0 ユーザーガイド#

link:UserGuide.asciidoc[English]

[[TOC_]]
=== 目次

1. <<Package,パッケージ>>
2. <<EntityClass,エンティティクラスの作成>> +
2-1. <<Entity-Annotation,エンティティクラスで使用するアノテーション>> +
2-1-1. <<Entity-Table,@Table>> +
2-1-2. <<Entity-Key,@Key>> +
2-1-3. <<Entity-Column,@Column>> +
2-1-4. <<Entity-ColumnType,@ColumnType>> +
2-1-5. <<Entity-NonColumn,@NonColumn>> +
2-1-6. <<Entity-NonSelect,@NonSelect>> +
2-1-7. <<Entity-NonInsert,@NonInsert>> +
2-1-8. <<Entity-NonUpdate,@NonUpdate>> +
2-1-9. <<Entity-Select,@Select>> +
2-1-10. <<Entity-Insert,@Insert>> +
2-1-11. <<Entity-Update,@Update>> +
2-1-12. <<Entity-XxxxxProperty,@KeyProperty, @ColumnProperty, ... @UpdateProperty>> +
2-2. <<Entity-Interface,エンティティクラスで実装するインターフェース>> +
2-2-1. <<Entity-PreInsert,PreInsert[small]##インターフェース##>> +
2-2-2. <<Entity-PreUpdate,PreUpdate[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
2-2-3. <<Entity-PreDelete,PreDelete[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
2-2-4. <<Entity-PostInsert,PostInsert[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
2-2-5. <<Entity-PostUpdate,PostUpdate[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
2-2-6. <<Entity-PostDelete,PostDelete[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
2-2-7. <<Entity-PostSelect,PostSelect[small]##インターフェース##>> [small fuchsia]#_(v3.2.0~)_# +
3. <<lightsleep-properties,lightsleep.propertiesファイルの定義>> +
3-1. <<Logger,ログライブラリクラス>> +
3-2. <<Database,データベースハンドラクラス>> +
3-3. <<ConnectionSupplier,コネクションサプライヤクラス>> +
4. <<Transaction,トランザクション>> +
5. <<ExecuteSQL,SQLの実行>> +
5-1. <<ExecuteSQL-select,SELECT>> +
5-1-1. <<ExecuteSQL-select-1-Expression,SELECT 1行/式条件>> +
5-1-2. <<ExecuteSQL-select-Entity,SELECT 1行/エンティティ条件>> +
5-1-3. <<ExecuteSQL-select-N-Expression,SELECT 複数行/式条件>> +
5-1-4. <<ExecuteSQL-select-Subquery,SELECT サブクエリ条件>> +
5-1-5. <<ExecuteSQL-select-Expression-and,SELECT 式条件/AND>> +
5-1-6. <<ExecuteSQL-select-Expression-or,SELECT 式条件/OR>> +
5-1-7. <<ExecuteSQL-select-Expression-andor,SELECT 式条件/SELECT 式条件/A AND B OR C AND D>> +
5-1-8. <<ExecuteSQL-select-columns,SELECTカラムの選択>> +
5-1-9. <<ExecuteSQL-select-groupBy-having,SELECT GROUP BY, HAVING>> +
5-1-10. <<ExecuteSQL-select-orderBy-offset-limit,SELECT ORDER BY, OFFSET, LIMIT>> +
5-1-11. <<ExecuteSQL-select-forUpdate,SELECT FOR UPDATE>> +
5-1-12. <<ExecuteSQL-select-innerJoin,SELECT 内部結合>> +
5-1-13. <<ExecuteSQL-select-leftJoin,SELECT 左外部結合>> +
5-1-14. <<ExecuteSQL-select-rightJoin,SELECT 右外部結合>> +
5-1-15. <<ExecuteSQL-select-count,SELECT COUNT(*)>> +
5-1-16. <<ExecuteSQL-select-fromSubquery,SELECT FROM句サブクエリ [small fuchsia]#_(v3.1.0~)_#>> +
5-1-17. <<ExecuteSQL-select-union,SELECT UNION, UNION ALL [small fuchsia]#_(v3.1.0~)_#>> +
5-1-18. <<ExecuteSQL-select-with,SELECT WITH句 [small fuchsia]#_(v4.0.0~)_#>> +
5-1-19. <<ExecuteSQL-select-recursive,SELECT RECURSIVE [small fuchsia]#_(v4.0.0~)_#>> +
5-2. <<ExecuteSQL-insert,INSERT>> +
5-2-1. <<ExecuteSQL-insert-1,INSERT 1行>> +
5-2-2. <<ExecuteSQL-insert-N,INSERT 複数行>> +
5-3. <<ExecuteSQL-update,UPDATE>> +
5-3-1. <<ExecuteSQL-update-1,UPDATE 1行>> +
5-3-2. <<ExecuteSQL-update-N,UPDATE 複数行>> +
5-3-3. <<ExecuteSQL-update-Condition,UPDATE 指定条件, カラム選択>> +
5-3-4. <<ExecuteSQL-update-all,UPDATE 全行>> +
5-4. <<ExecuteSQL-delete,DELETE>> +
5-4-1. <<ExecuteSQL-delete-1,DELETE 1行>> +
5-4-2. <<ExecuteSQL-delete-N,DELETE 複数行>> +
5-4-3. <<ExecuteSQL-delete-Condition,DELETE 指定条件>> +
5-4-4. <<ExecuteSQL-delete-all,DELETE 全行>> +
6. <<Expression,式の変換処理>> +
7. <<DateTime,日時型おけるJava型とカラム型の対応>> +
7-1. <<DateTime-DB2,DB2>> +
7-2. <<DateTime-MariaDB_MySQL,MariaDB, MySQL>> +
7-3. <<DateTime-Oracle,Oracle>> +
7-4. <<DateTime-PostgreSQL,PostgreSQL>> +
7-5. <<DateTime-SQLite,SQLite>> +
7-6. <<DateTime-SQLServer,SQL Server>> +

[[Package]]

<<TOC_,目次へ>>

=== 1. パッケージ

以下のパッケージがあります。

.パッケージ一覧
[options="header", width="80%"]
|===
|パッケージ|含まれるクラス/インタフェース
|`org.lightsleep`                |主に使用するクラス
|`org.lightsleep.component`      |条件や式などのSQLの構成要素を作成する際に使用するクラス
|`org.lightsleep.connection`     |各種コネクションプールライブラリを利用してコネクションラッパークラスを供給するクラス
|`org.lightsleep.database`       |各種DBMS用のSQLを生成するクラス
|`org.lightsleep.database.anchor`|JDBC URLに含まれる文字列と``org.lightsleep.database``パッケージのクラスとの対応付けで使用されるクラス
|`org.lightsleep.entity`         |エンティティクラスを作成する際に使用するアノテーションクラスおよびインタフェース
|`org.lightsleep.helper`         |ライブラリ内部で使用される補助的なクラス
|`org.lightsleep.logger`         |各種ロギングライブラリを利用してライブラリ内部のログを出力するクラス
|===

[[EntityClass]]

<<TOC_,目次へ>>

=== 2. エンティティクラスの作成
データベースのテーブル毎に対応するエンティティクラスを作成します。

[[Entity-Annotation]]

==== 2-1. エンティティクラスで使用するアノテーション
Lihgtsleepは、エンティティクラスまたはオブジェクトを引数とするメソッドでは自動的にテーブルとの関連付けを行いますが、エンティティクラスにアノテーションの付与が必要な場合があります。

Lightsleepには、以下のアノテーションがあります。

.アノテーション一覧
[options="header", width="100%"]
|===
|アノテーション型|要素|示す内容|付与する対象
|<<Entity-Table,`@Table`>>
|String value
|関連するテーブル名
|クラス

|<<Entity-Key,`@Key`>>
|`boolean value` (省略値: `true`)
|プライマリキーに対応
|フィールド

|<<Entity-Column,`@Column`>>
|String value
|関連するカラムの名前
|フィールド

|<<Entity-ColumnType,`@ColumnType`>>
|Class<?> value
|関連するカラムの型
|フィールド

|<<Entity-NonColumn,`@NonColumn`>>
|`boolean value` (省略値: `true`)
|カラムに関連しない
|フィールド

|<<Entity-NonSelect,`@NonSelect`>>
|`boolean value` (省略値: `true`)
|SELECT SQLに使用しない
|フィールド

|<<Entity-NonInsert,`@NonInsert`>>
|`boolean value` (省略値: `true`)
|INSERT SQLに使用しない
|フィールド

|<<Entity-NonUpdate,`@NonUpdate`>>
|`boolean value` (省略値: `true`)
|UPDATE SQLに使用しない
|フィールド

|<<Entity-Select,`@Select`>>
|String value
|SELECT SQLで使用する式
|フィールド

|<<Entity-Insert,`@Insert`>>
|String value
|INSERT SQLで使用する式
|フィールド

|<<Entity-Update,`@Update`>>
|String value
|UPDATE SQLで使用する式
|フィールド

|<<Entity-XxxxxProperty,`@KeyProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|プライマリキーに対応
|クラス

|<<Entity-XxxxxProperty,`@ColumnProperty`>>
|`String property`, +
String column
|関連するカラムの名前
|クラス

|<<Entity-XxxxxProperty,`@ColumnTypeProperty`>>
|`String property`, +
`Class<?> type`
|関連するカラムの型
|クラス

|<<Entity-XxxxxProperty,`@NonColumnProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|カラムに関連しない
|クラス

|<<Entity-XxxxxProperty,`@NonSelectProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|SELECT SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@NonInsertProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|INSERT SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@NonUpdateProperty`>>
|`String property`, +
`boolean value` (省略値: `true`)
|UPDATE SQLに使用しない
|クラス

|<<Entity-XxxxxProperty,`@SelectProperty`>>
|`String property`, +
`String expression`
|SELECT SQLで使用する式
|クラス

|<<Entity-XxxxxProperty,`@InsertProperty`>>
|`String property`, +
`String expression`
|INSERT SQLで使用する式
|クラス

|<<Entity-XxxxxProperty,`@UpdateProperty`>>
|`String property`, +
`String expression`
|UPDATE SQLで使用する式
|クラス
|===

[[Entity-Table]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-1. @Table
クラスに関連するデータベーステーブル名を示します。
テーブル名がクラス名と同じであれば、このアノテーションを指定する必要はありません。

[source,java]
.Java[small]##での例##
----
import org.lightsleep.entity.*;

@Table("Contact")
public class Contact1 extends Contact {
   ...
}
----

``@Table("super")``を指定した場合は、スーパークラスのクラス名がテーブル名となります。

[source,java]
.Java[small]##での例##
----
@Table("Contact")
public class Person extends PersonBase {

    @Table("super")
     public static class Ex extends Person {
----

[source,groovy]
.Groovy[small]##での例##
----
@Table('Contact')
class Person extends PersonBase {

    @Table('super')
     static class Ex extends Person {
----

[[Entity-Key]]

===== 2-1-2. @Key
フィールドに関連するカラムがプライマリーキーの一部である事を示します。

[source,java]
.Java[small]##での例##
----
@Key
public int contactId;
@Key
public short featureIndex;
----

[source,groovy]
.Groovy[small]##での例##
----
@Key
int contactId
@Key
short featureIndex
----

[[Entity-Column]]

===== 2-1-3. @Column
フィールドに関連するデータベースカラム名を示します。
カラム名がフィールド名と同じであれば、このアノテーションを指定する必要がありません。

[source,java]
.Java[small]##での例##
----
@Column("firstName")
public String first;
@Column("lastName")
public String last;
----

[source,groovy]
.Groovy[small]##での例##
----
@Column('firstName')
String first
@Column('lastName')
String last
----

[[Entity-ColumnType]]

===== 2-1-4. @ColumnType
フィールドに関連するカラムの型を示します。
フィールド型とカラム型が同種類の場合は、指定する必要がありません。
フィールド型が日付型で、カラム型が数値型のように異なる場合に指定します。

[source,java]
.Java[small]##での例##
----
@ColumnType(Long.class)
public LocalDate birthday;
----

[source,groovy]
.Groovy[small]##での例##
----
@ColumnType(Long)
LocalDate birthday
----

[[Entity-NonColumn]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-5. @NonColumn
フィールドがどのカラムにも関連しない事を示します。

[source,java]
.Java[small]##での例##
----
@NonColumn
public List<Phone> phones;
@NonColumn
public List<Address> addresses;
----

[source,groovy]
.Groovy[small]##での例##
----
@NonColumn
List<Phone> phones
@NonColumn
List<Address> addresses
----

[[Entity-NonSelect]]

===== 2-1-6. @NonSelect
フィールドに関連するカラムがSELECT SQLで使用されない事を示します。

[source,java]
.Java[small]##での例##
----
@NonSelect
public LocalDateTime createdTime;
@NonSelect
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy[small]##での例##
----
@NonSelect
LocalDateTime createdTime
@NonSelect
LocalDateTime updatedTime
----

[[Entity-NonInsert]]

===== 2-1-7. @NonInsert
フィールドに関連するカラムがINSERT SQLで使用されない事を示します。

[source,java]
.Java[small]##での例##
----
@NonInsert
public LocalDateTime createdTime;
@NonInsert
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy[small]##での例##
----
@NonInsert
LocalDateTime createdTime
@NonInsert
LocalDateTime updatedTime
----

[[Entity-NonUpdate]]

===== 2-1-8. @NonUpdate
フィールドに関連するカラムがUPDATE SQLで使用されない事を示します。

[source,java]
.Java[small]##での例##
----
@NonUpdate
public LocalDateTime createdTime;
----

[source,groovy]
.Groovy[small]##での例##
----
@NonUpdate
LocalDateTime createdTime
----

[[Entity-Select]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-9. @Select
SELECT SQLのカラム名の代わりの式を指定します。

[source,java]
.Java[small]##での例##
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
public String fullName;
----

[source,groovy]
.Groovy[small]##での例##
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
String fullName
----

[[Entity-Insert]]

===== 2-1-10. @Insert
INSERT SQLの挿入値の式を示します。
このアノテーションが指定された場合、フィールドの値は使用されません。

[source,java]
.Java[small]##での例##
----
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime createdTime;
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy[small]##での例##
----
@Insert('CURRENT_TIMESTAMP')
LocalDateTime createdTime
@Insert('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-Update]]

===== 2-1-11. @Update
UPDATE SQLの更新値の式を示します。
このアノテーションが指定された場合、フィールドの値は使用されません。

[source,java]
.Java[small]##での例##
----
@Update("{updateCount}+1")
public int updateCount;
@Update("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy[small]##での例##
----
@Update('{updateCount}+1')
int updateCount
@Update('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-XxxxxProperty]]

<<TOC_,目次へ>> +
<<Entity-Annotation,アノテーション一覧へ>>

===== 2-1-12. @KeyProperty, @ColumnProperty, ... @UpdateProperty
これらのアノテーションは、スーパークラスで定義されているフィールドに対して指定する場合に使用します。
指定された内容はサブクラスにも影響しますが、サブクラスでの指定が優先されます。
`value=false`, `column=""`, `type=Void.class`, `expression=""` を指定すると、スーパークラスでの指定が打ち消されます。

[source,java]
.Java[small]##での例##
----
@KeyProperty(property="contactId")
@KeyProperty(property="featureIndex")
public class ContactFeature extends ContactFeatureKey {
----

[source,groovy]
.Groovy[small]##での例##
----
@KeyProperties([
    @KeyProperty(property='contactId'),
    @KeyProperty(property='featureIndex')
])
class ContactFeature extends ContactFeatureKey {
----

[[Entity-Interface]]

=== 2-2. エンティティクラスで実装するインターフェース

[[Entity-PreInsert]]

<<TOC_,目次へ>>

==== 2-2-1. PreInsert[small]##インターフェース##
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``insert(E)``および``insert(Iterable)``メソッドからINSERT SQLの実行前に``preInsert``メソッドが呼び出されます。

``preInsert``メソッドを使用して、プライマリーキーの採番の実装をする事ができます。

[source,java]
.Java[small]##での例##
----
public abstract class Common implements PreInsert {
    @Key
    public int id;

    @Override
    public void preInsert(ConnectionWrapper conn) {
        id = Numbering.getNewId(conn, getClass());
    }
}
----

[[Entity-PreUpdate]]

<<TOC_,目次へ>>

==== 2-2-2. PreUpdate[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``update(E)``および``update(Iterable)``メソッドからUPDATE SQLの実行前に``preUpdate``メソッドが呼び出されます。

[[Entity-PreDelete]]

<<TOC_,目次へ>>

==== 2-2-3. PreDelete[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``delete(E)``および``delete(Iterable)``メソッドからDELETE SQLの実行前に``preDelete``メソッドが呼び出されます。

[[Entity-PostInsert]]

<<TOC_,目次へ>>

==== 2-2-4. PostInsert[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``insert(E)``および``insert(Iterable)``メソッドからINSERT SQLの実行後に``postInsert``メソッドが呼び出されます。

エンティティが他のエンティティを内包する場合、このインターフェースを実装する事で、内包するエンティティへの SQL 処理を連動して行う事ができます。

また``postInsert``メソッドを使用して、挿入時に自動採番された値を取得する事ができます。

[source,java]
.Java[small]##での例##
----
public abstract class Common implements PostInsert {
    @Key
    @NonInsert
    public int id;

    @Override
    public void postInsert(Connection conn) {
        Class<? extends Common> entityClass = getClass();
        if (PostSelect.class.isAssignableFrom(entityClass))
            entityClass = (Class<? extends Common>)entityClass.getSuperclass();
        new Sql<>(entityClass)
            .columns("id")
            .where("id=",
                new Sql<>(entityClass)
                    .columns("id")
                    .expression("id", "MAX({id})")
            )
            .connection(conn)
            .select(entity -> id = entity.id);
    }
}

public class Contact extends Common {
    public String firstName;
    public String lastName;
    public Date birthday;
}
----

[source,sql]
.INSERT [small]#時に生成される# SQL
----
INSERT INTO Contact (firstName, lastName, birthday) VALUES ('Yukari', 'Apple', DATE'2001-01-10')
SELECT id FROM Contact WHERE id= (SELECT MAX(id) id FROM Contact)
----

[[Entity-PostUpdate]]

<<TOC_,目次へ>>

==== 2-2-5. PostUpdate[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``update(E)``および``update(Iterable)``メソッドからUPDATE SQLの実行後に``postUpdate``メソッドが呼び出されます。

エンティティが他のエンティティを内包する場合、このインターフェースを実装する事で、内包するエンティティへの SQL 処理を連動して行う事ができます。

[[Entity-PostDelete]]

<<TOC_,目次へ>>

==== 2-2-6. PostDelete[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、``Sql<E>``クラスの``delete(E)``および``delete(Iterable)``メソッドからDELETE SQLの実行後に``postDelete``メソッドが呼び出されます。

エンティティが他のエンティティを内包する場合、このインターフェースを実装する事で、内包するエンティティへの SQL 処理を連動して行う事ができます。

[[Entity-PostSelect]]

<<TOC_,目次へ>>

==== 2-2-7. PostSelect[small]##インターフェース## [small fuchsia]#_(v3.2.0~)_#
エンティティクラスがこのインターフェースを実装している場合、SELECT SQLを実行してエンティティを取得した後に``postSelect``メソッドが呼び出されます。

エンティティが他のエンティティを内包する場合、このインターフェースを実装する事で、内包するエンティティへの SQL 処理を連動して行う事ができます。

[[Entity-Composite]]

<<TOC_,目次へ>>

[source,java]
.Java[small]##での例##
----
@Table("super")
public class ContactComposite extends Contact implements PostSelect, PostInsert, PostUpdate, PostDelete {
    @NonColumn
    public final var phones = new ArrayList<Phone>();

    @Override
    public void postSelect(ConnectionWrapper conn) {
        if (id != 0) {
            new Sql<>(Phone.class)
                .where("{contactId}={}", id)
                .orderBy("{phoneNumber}")
                .connection(conn)
                .select(phones::add);
        }
    }

    @Override
    public int postInsert(ConnectionWrapper conn) {
        phones.forEach(phone -> phone.contactId = id);
        new Sql<>(Phone.class)
            .insert(phones);
            .connection(conn)
    }

    @Override
    public void postUpdate(ConnectionWrapper conn) {
        List<Integer> phoneIds = phones.stream()
            .map(phone -> phone.id)
            .filter(id -> id != 0)
            .collect(Collectors.toList());

        // Delete phones
        new Sql<>(Phone.class)
            .where("{contactId}={}", id)
            .doIf(phoneIds.size() > 0,
                sql -> sql.and("{id} NOT IN {}", phoneIds)
            )
            .connection(conn)
            .delete();

        // Uptete phones
        new Sql<>(Phone.class)
            .connection(conn)
            .update(phones.stream()
                .filter(phone -> phone.id != 0)
                .collect(Collectors.toList()));

        // Insert phones
        new Sql<>(Phone.class)
            .connection(conn)
            .insert(phones.stream()
                .filter(phone -> phone.id == 0)
                .collect(Collectors.toList()));
    }

    @Override
    public void postDelete(ConnectionWrapper conn) {
        new Sql<>(Phone.class)
            .connection(conn)
            .where("{contactId}={}", id)
            .delete();
    }
----

[[lightsleep-properties]]

<<TOC_,目次へ>>

[[lightsleep-properties]]
=== 3. lightsleep.propertiesの定義

lightsleep.propertiesは、Lightsleepが参照するプロパティファイルで、以下の内容を指定できます。 +
*(バージョン2.0.0まで存在した `Database` プロパティは、バージョン2.1.0で削除されました。データベースハンドラは、JDBC URLから自動的に決定されます。)*

[options="header", width="80%"]
|===
|プロパティ名|指定する内容|デフォルト値
|`<<Logger,Logger>>`
|ログ出力クラス
|`Std$Out$Info`

|`<<ConnectionSupplier,ConnectionSupplier>>`
|コネクションサプライヤクラス
|`Jdbc`

|`url`                   |JDBC URL|なし
|`urls`                  |JDBC URL(複数)|なし
|`dataSource`            |``Jndi``を使用した場合のデータソース名|なし
|`dataSources`           |``Jndi``を使用した場合のデータソース名(複数)|なし
|`maxStringLiteralLength`|SQLが生成される時の文字列リテラルの最大長|128
|`maxBinaryLiteralLength`|SQLが生成される時のバイナリ列リテラルの最大長|128
|`maxLogStringLength`    |ログに出力する文字列値の最大長|200
|`maxLogByteArrayLength` |ログに出力するバイト配列の最大要素数|200
|`maxLogArrayLength`     |ログに出力する配列の最大要素数|100
|`maxLogMapSize`         |ログに出力するマップの最大要素数|100

|`connectionLogFormat` +
[small fuchsia]#_(v2.2.0~)_#
|`ConnectionSupplier` のログ出力フォーマット +
*文字列の置換:* +
*{0}*: データベースハンドラのクラス名 +
*{1}*: コネクションサプライヤのクラス名 +
*{2}*: 接続先JDBC URL
|`[{0}/{1}]`
|===

`lightsleep.properties` ファイルは、クラスパスのいずれかに置いてください。あるいはシステムプロパティ `lightsleep.resource` でファイルパスを指定する事もできます。*(java -Dlightsleep.resource=...)* +
上記以外にもコネクションプールライブラリが使用するプロパティを定義します。

lightsleep.propertiesの例: +

[source,properties]
.lightsleep.properties
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
url         = jdbc:postgresql://postgresqlserver/example
user        = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

``urls``プロパティにカンマ区切りで複数のJDBC URLを指定できます。[small fuchsia]#_(v2.1.0~)_# +
1つのプロパティを複数行で定義する場合は、最後の行以外の行末にバックスラッシュ(`\`)を付加します。 +
``urls``を指定した場合は、``url``の指定は無効になります。

[source,properties]
.lightsleep.properties - 複数のJDBC URLを指定する場合
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
urls        = jdbc:postgresql://postgresqlserver/example1,\
              jdbc:postgresql://postgresqlserver/example2
user        = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

JDBC URL毎に異なるDBMSのURLを指定できます。JDBC URL毎にユーザー、パスワードが異なる場合は、URL内で指定してください。

[source,properties]
.lightsleep.properties - 複数のDBMSを使用する場合(URL内でユーザーとパスワードを指定)
----
Logger = Log4j2
ConnectionSupplier = Dbcp
urls = \
    jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    jdbc:mariadb://mariadb:3306/example?user=example&password=_example_,\
    jdbc:mysql://mysql:3306/example?user=example&password=_example_,\
    jdbc:oracle:thin:example/_example_@oracle122:1521:example,\
    jdbc:postgresql://postgresql:5432/example?user=example&password=_example_,\
    jdbc:sqlite:C:/sqlite/example,\
    jdbc:sqlserver://sqlserver:1433;database=example;user=example;password=_example_,\

initialSize = 10
maxTotal    = 100
----

URL毎にコネクションサプライヤを指定する場合は、URLの先頭の``[]``内に記述します。[small fuchsia]#_(v2.1.0~)_# +
この形式の指定は、``ConnectionSupplier``プロパティの指定よりも優先されます。 +
`username`, ``jdbcUrl``プロパティは、`user`, ``url``プロパティで指定する事ができますが、それら以外はコネクションプールライブラリ固有のプロパティ名で指定してください。

[source,properties]
.lightsleep.properties - URL毎にコネクションサプライヤを指定する場合
----
Logger = Log4j2
urls = \
    [  Jdbc  ]jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    [  C3p0  ]jdbc:mariadb://mariadb:3306/example?user=example&password=_example_,\
    [  Dbcp  ]jdbc:mysql://mysql:3306/example?user=example&password=_example_,\
    [HikariCP]jdbc:oracle:thin:example/_example_@oracle122:1521:example,\
    [TomcatCP]jdbc:postgresql://postgresql:5432/example?user=example&password=_example_,\
    [  Jdbc  ]jdbc:sqlite:C:/sqlite/example,\
    [  C3p0  ]jdbc:sqlserver://sqlserver:1433;database=example;user=example;password=_example_,\

# Dbcp, HikariCP, TomcatCP
initialSize = 10

# Dbcp
maxTotal    = 10

# TomcatCP
maxActive   = 10

# HikariCP
minimumIdle     = 10
maximumPoolSize = 10
----

[[Logger]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-1. ログライブラリクラスの指定

Loggerプロパティの値は以下から選択してください。

[options="header", width="80%"]
|===
|指定値|ログライブラリなど|ログレベル|ログライブラリが使用する定義ファイル
|`Jdk`          |Java Runtime    |－   |logging.properties
|`Log4j`        |Log4j           |－   |log4j.propertiesまたはlog4j.xml
|`Log4j2`       |Log4j 2         |－   |log4j2.xml
|`SLF4J`        |SLF4J           |－   |対象とするログライブラリ実装に依存
|`Std$Out$Trace`|System.outに出力|trace|－
|`Std$Out$Debug`|_同上_          |debug|－
|`Std$Out$Info` |_同上_          |info |－
|`Std$Out$Warn` |_同上_          |warn |－
|`Std$Out$Error`|_同上_          |error|－
|`Std$Out$Fatal`|_同上_          |fatal|－
|`Std$Err$Trace`|System.errに出力|trace|－
|`Std$Err$Debug`|_同上_          |debug|－
|`Std$Err$Info` |_同上_          |info |－
|`Std$Err$Warn` |_同上_          |warn |－
|`Std$Err$Error`|_同上_          |error|－
|`Std$Err$Fatal`|_同上_          |fatal|－
|===

指定がない場合は、``Std$Out$Info``が選択されます。

[[Database]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-2. データベースハンドラクラス

データベースハンドラクラスは、``url``または``urls``プロパティで指定されたJDBC URLの内容から自動的に選択されます。[small fuchsia]#_(v2.1.0~)_#

[options="header", width="60%"]
|===
|JDBC URLに含まれる文字列|選択されるクラス|対応するDBMS
|`db2`       |`DB2`       |link:https://www.ibm.com/us-en/marketplace/db2-express-c[DB2]
|`mariadb`   |`MariaDB`   |link:https://mariadb.org/[MariaDB] [small fuchsia]#_(v3.2.0~)_#
|`mysql`     |`MySQL`     |link:https://www.mysql.com/[MySQL]
|`oracle`    |`Oracle`    |link:https://www.oracle.com/database/index.html[Oracle Database]
|`postgresql`|`PostgreSQL`|link:https://www.postgresql.org/[PostgreSQL]
|`sqlite`    |`SQLite`    |link:https://sqlite.org/index.html[SQLite]
|`sqlserver` |`SQLServer` |link:https://www.microsoft.com/ja-jp/sql-server/sql-server-2017[Microsoft SQL Server]
|===

JDBC URLに上記の文字列のいずれもが含まれていない場合、``Standard``クラスが選択されます。

[[ConnectionSupplier]]

<<TOC_,目次へ>> <<lightsleep-properties,【プロパティ一覧へ】>>

==== 3-3. コネクションを供給するクラスの指定

ConnectionSupplierプロパティの値は以下から選択してください。JDBC URLの先頭の``[]``内で指定する事もできます。

[options="header", width="60%"]
|===
|指定値|対応するコネクションプールライブラリ
|`C3p0`    |link:http://www.mchange.com/projects/c3p0/[c3p0]
|`Dbcp`    |link:https://commons.apache.org/proper/commons-dbcp/[Apache Commons DBCP]
|`HikariCP`|link:https://github.com/brettwooldridge/HikariCP[HikariCP]
|`TomcatCP`|link:http://tomcat.apache.org/tomcat-9.0-doc/jdbc-pool.html[Tomcat JDBC Connection Pool]
|`Jndi`    |Java Naming and Directory Interface (JNDI) (link:http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html[Tomcatの場合])
|`Jdbc`    |`DriverManager#getConnection(String url, Properties info)` メソッド
|===

`C3p0`, `Dbcp 2`, `HikariCP`, ``TomcatCP``クラスは、それぞれ対応するコネクションプールライブラリを使用してデータベースコネクションを取得します。 +
``Jndi``クラスは、JNDI (Java Naming and Directory Interface)を使用して取得したデータソース(`javax.sql.DataSource`)からデータベースコネクションを取得します。 +
``Jdbc``クラスは、``java.sql.DriverManager.getConnection``メソッドを使用してデータベースコネクションを取得します。 +
コネクションプールライブラリが必要する情報もlightsleep.propertiesファイルに定義してください。
以下のlightsleep.propertiesの定義例のConnectionSupplierより下(url ~)は、コネクションプールライブラリに渡す内容です。

[source,properties]
.lightsleep.properties - Jdbc
----
ConnectionSupplier = Jdbc
url      = jdbc:db2://db2-11:50000/example
user     = example
password = _example_
----

[source,properties]
.lightsleep.properties - C3p0
----
ConnectionSupplier = C3p0
url      = jdbc:mysql://mysql57/example
user     = example
password = _example_
----

[source,properties]
.c3p0.properties
----
c3p0.initialPoolSize = 20
c3p0.minPoolSize     = 10
c3p0.maxPoolSize     = 30
----

[source,properties]
.lightsleep.properties - Dbcp
----
ConnectionSupplier = Dbcp
url         = jdbc:oracle:thin:@oracle121:1521:example
user        = example
  または
username    = example
password    = _example_
initialSize = 20
maxTotal    = 30
----

[source,properties]
.lightsleep.properties - HikariCP
----
ConnectionSupplier = HikariCP
url             = jdbc:postgresql://postgres96/example
  または
jdbcUrl         = jdbc:postgresql://postgres96/example
user            = example
  または
username        = example
password        = _example_
minimumIdle     = 10
maximumPoolSize = 30
----

[source,properties]
.lightsleep.properties - TomcatCP
----
ConnectionSupplier = TomcatCP
url         = jdbc:sqlserver://sqlserver13;database=example
user        = example
  または
username    = example
password    = _example_
initialSize = 20
maxActive   = 30
----

[source,properties]
.lightsleep.properties - Jndi
----
ConnectionSupplier = Jndi
dataSource         = jdbc/example
  または
dataSource         = example
----

<<TOC_,目次へ>>

=== 4. トランザクション

``Transaction.execute``メソッドの実行が1つのトランザクションの実行に相当します。
トランザクションの内容を引数``transaction``(ラムダ式) で定義してください。
ラムダ式は、``Transaction.executeBody``メソッドの内容に相当し、このメソッドの引数は、``ConnectionWrapper``です。

[source,java]
.Java[small]##での例##
----
var contact = new Contact(1, "Akane", "Apple");

Transaction.execute(conn -> {
    // トランザクション開始
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
   ...
    // トランザクション終了
});
----

[source,groovy]
.Groovy[small]##での例##
----
def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute {
    // トランザクション開始
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // トランザクション終了
}
----

複数のJDBC URLを ``lightsleep.properties``に定義した場合は、どのURLに対してトランザクションの実行を行うかを指定する必要があります。 ``ConnectionSupplier.find``メソッドは、引数の文字列配列のすべてが含まれるJDBC URLを検索します。
複数見つかった場合または見つからない場合は例外がスローされます。

[source,java]
.Java[small]##での例##
----
public static final ConnectionSupplier supplier1 = ConnectionSupplier.find("example1");
    ...

var contact = new Contact(1, "Akane", "Apple");

Transaction.execute(supplier1, conn -> {
    // トランザクション開始
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
   ...
    // トランザクション終了
});
----

[source,groovy]
.Groovy[small]##での例##
----
static final supplier1 = ConnectionSupplier.find('example1')
    ...

def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute(supplier1) {
    // トランザクション開始
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // トランザクション終了
}
----

トランザクション中に例外がスローされた場合は、``Transaction.rollback``メソッドが実行され、
そうでなければ ``Transaction.commit``メソッドが実行されます。

[[ExecuteSQL]]

<<TOC_,目次へ>>

=== 5. SQLの実行
SQLの実行は、``Sql``クラスの各種メソッドを使用し、``Transaction.execute``メソッドの引数のラムダ式内に定義します。

[[ExecuteSQL-select]]

==== 5-1. SELECT

[[ExecuteSQL-select-1-Expression]]

==== 5-1-1. SELECT 1行/式条件

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn -> {
    var contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-Entity]]

<<TOC_,目次へ>>

==== 5-1-2. SELECT 1行/エンティティ条件

[source,java]
.Java[small]##での例##
----
var contact = new Contact();
contact.id = 1;
Transaction.execute(conn -> {
    var contactOpt = new Sql<>(Contact.class)
        .where(contact)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy[small]##での例##
----
def contact = new Contact()
contact.id = 1
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where(contact)
        .connection(it)
        .select()
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-N-Expression]]

<<TOC_,目次へ>>

==== 5-1-3. SELECT 複数行/式条件

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it})
}
----


[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple'
----

[[ExecuteSQL-select-Subquery]]

<<TOC_,目次へ>>

==== 5-1-4. SELECT サブクエリ条件

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .where("EXISTS",
            new Sql<>(Phone.class, "P")
                .where("{P.contactId}={C.id}")
        )
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .where('EXISTS',
            new Sql<>(Phone, 'P')
                .where('{P.contactId}={C.id}')
        )
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime
  FROM Contact C
  WHERE EXISTS (SELECT * FROM Phone P WHERE P.contactId=C.id)
----

[[ExecuteSQL-select-Expression-and]]

<<TOC_,目次へ>>

==== 5-1-5. SELECT 式条件/AND

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .and  ("{firstName}={}", "Akane")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .and  ('{firstName}={}', 'Akane')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane'
----

[[ExecuteSQL-select-Expression-or]]

<<TOC_,目次へ>>

==== 5-1-6. SELECT 式条件/OR

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .or   ("{lastName}={}", "Orange")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .or   ('{lastName}={}', 'Orange')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' OR lastName='Orange'
----

[[ExecuteSQL-select-Expression-andor]]

<<TOC_,目次へ>>

==== 5-1-7. SELECT 式条件/A AND B OR C AND D

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition
            .of ("{lastName}={}", "Apple")
            .and("{firstName}={}", "Akane")
        )
        .or(Condition
            .of ("{lastName}={}", "Orange")
            .and("{firstName}={}", "Setoka")
        )
        .connection(conn)
        .select(contacts::add)
);
----
[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute(conn ->
    new Sql<>(Contact)
        .where(Condition
            .of ('{lastName}={}', 'Apple')
            .and('{firstName}={}', 'Akane')
        )
        .or(Condition
            .of ('{lastName}={}', 'Orange')
            .and('{firstName}={}', 'Setoka')
        )
        .connection(it)
        .select({contacts << it})
);
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane' OR lastName='Orange' AND firstName='Setoka'
----

[[ExecuteSQL-select-columns]]

<<TOC_,目次へ>>

==== 5-1-8. SELECTカラムの選択

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .columns("lastName", "firstName")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .columns('lastName', 'firstName')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT firstName, lastName FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-groupBy-having]]

<<TOC_,目次へ>>

==== 5-1-9. SELECT GROUP BY, HAVING

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .columns("lastName")
        .groupBy("{lastName}")
        .having("COUNT({lastName})>=2")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .columns('lastName')
        .groupBy('{lastName}')
        .having('COUNT({lastName})>=2')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT MIN(C.lastName) C_lastName FROM Contact C GROUP BY C.lastName HAVING COUNT(C.lastName)>=2
----

[[ExecuteSQL-select-orderBy-offset-limit]]

<<TOC_,目次へ>>

==== 5-1-10. SELECT ORDER BY, OFFSET, LIMIT

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .orderBy("{lastName}")
        .orderBy("{firstName}")
        .orderBy("{id}")
        .offset(10).limit(5)
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .orderBy('{lastName}')
        .orderBy('{firstName}')
        .orderBy('{id}')
        .offset(10).limit(5)
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL - DB2, MariaDB, MySQL, PostgreSQL, SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
  LIMIT 5 OFFSET 10
----

[source,sql]
.[small]##生成される##SQL - Oracle, SQLServer (取得時に行をスキップする)
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
----

[[ExecuteSQL-select-forUpdate]]

<<TOC_,目次へ>>

==== 5-1-11. SELECT FOR UPDATE

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn -> {
    var contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .forUpdate()
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .forUpdate()
        .connection(it)
        .select()
}
----

[source,sql]
.[small]##生成される##SQL - DB2
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE WITH RS
----

[source,sql]
.[small]##生成される##SQL - MariaDB, MySQL, Oracle, PostgreSQL, SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE
----

[source,sql]
.[small]##生成される##SQL - SQLite
----
-- SQLiteでは、FOR UPDATEをサポートしていないのでUnsupportedOperationExceptionがスローされます。
----

[source,sql]
.[small]##生成される##SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WITH (ROWLOCK,UPDLOCK) WHERE id=1
----

[[ExecuteSQL-select-innerJoin]]

<<TOC_,目次へ>>

==== 5-1-12. SELECT 内部結合

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
var phones = new ArrayList<Phone>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .innerJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.id}={}", 1)
        .connection(conn)
        .select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .innerJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.id}={}', 1)
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  INNER JOIN Phone P ON P.contactId=C.id
  WHERE C.id=1
----

[[ExecuteSQL-select-leftJoin]]

<<TOC_,目次へ>>

==== 5-1-13. SELECT 左外部結合

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
var phones = new ArrayList<Phone>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .leftJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.lastName}={}", "Apple")
        .connection(conn)
        .select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .leftJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  LEFT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE C.lastName='Apple'
----

[[ExecuteSQL-select-rightJoin]]

<<TOC_,目次へ>>

==== 5-1-14. SELECT 右外部結合

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
var phones = new ArrayList<Phone>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .rightJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{P.label}={}", "Main")
        .connection(conn)
        .select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .rightJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{P.label}={}', 'Main')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
-- SQLiteでは、RIGHT OUTER JOINが未サポートのため、例外がスローされます。
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  RIGHT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE P.label='Main'
----

[[ExecuteSQL-select-count]]

<<TOC_,目次へ>>

==== 5-1-15. SELECT COUNT(*)

[source,java]
.Java[small]##での例##
----
var count = new int[1];
Transaction.execute(conn ->
    count[0] = new Sql<>(Contact.class)
        .where("lastName={}", "Apple")
        .connection(conn)
        .selectCount()
);
----

[source,groovy]
.Groovy[small]##での例##
----
def count = 0
Transaction.execute {
    count = new Sql<>(Contact)
        .where('lastName={}', 'Apple')
        .connection(it)
        .selectCount()
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT COUNT(*) FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-fromSubquery]]

<<TOC_,目次へ>>

==== 5-1-16. SELECT FROM句サブクエリ

[source,java]
.Java[small]##での例##
----
var contacts = new ArrayList<Contact>();
Transaction.execute(conn -> {
    Class<? extends Contact.Ex> contactClass = Contact.Ex.targetClass(conn.getDatabase());
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where("{fullName}={}", "Akane Apple")
        .orderBy("{fullName}")
        .connection(conn)
        .select(contacts::add);
});
----

[source,groovy]
.Groovy[small]##での例##
----
def contacts = []
Transaction.execute {
    def contactClass = Contact.Ex.targetClass(conn.database)
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where('{fullName}={}', 'Akane Apple')
        .orderBy('{fullName}')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, fullName
  FROM (
    SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, firstName||' '||lastName fullName FROM Contact
  ) Contact
  WHERE fullName='Akane Apple' ORDER BY fullName ASC
----

[[ExecuteSQL-select-union]]

<<TOC_,目次へ>>

==== 5-1-17. SELECT UNION, UNION ALL

[source,java]
.Java[small]##での例##
----
var features = new ArrayList<ContactFeature>();
var targetFirstName = "Setoka";
var targetLastName = "Orange";
Transaction.execute(conn -> {
    new Sql<>(ContactFeature.class, "F")
        .columns(ContactFeature.class)
        .unionAll(new Sql<>(Address.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Email.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Phone.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Url.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .orderBy("{F_label}")
        .connection(conn)
        .select(features::add);
});
----

[source,groovy]
.Groovy[small]##での例##
----
List<ContactFeature> features = []
def targetFirstName = 'Setoka'
def targetLastName = 'Orange'
Transaction.execute {
    new Sql<>(ContactFeature, 'F')
        .columns(ContactFeature)
        .unionAll(new Sql<>(Address)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Email)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Phone)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Url)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .orderBy('{F_label}')
        .connection(it)
        .select({features << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Address F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Email F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Phone F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Url F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
ORDER BY F_label ASC
----

[[ExecuteSQL-select-with]]

<<TOC_,目次へ>>

==== 5-1-18. SELECT WITH句

[source,java]
.Java[small]##での例##
----
var nodes = new ArrayList<Node>();
var nodeSql = new Sql<>(Node.class)
    .where("{name} LIKE {}", "%-%");
Transaction.execute(conn ->
    new Sql<>(Node.class)
        .with(nodeSql)
        .from(nodeSql)
        .connection(conn)
        .select(nodes::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Node> nodes = []
def nodeSql = new Sql<>(Node)
    .where('{name} LIKE {}', '%-%')
Transaction.execute {
    new Sql<>(Node)
        .with(nodeSql)
        .from(nodeSql)
        .connection(it)
        .select({nodes << it})
}
----

[source,sql]
.[small]##生成される##SQL
----
WITH W1(id, parentId, name) AS (
  SELECT id, parentId, name FROM Node WHERE name LIKE '%-%'
)
SELECT id, parentId, name FROM W1
----

[[ExecuteSQL-select-recursive]]

<<TOC_,目次へ>>

==== 5-1-19. SELECT RECURSIVE

[source,java]
.Java[small]##での例##
----
var nodes = new ArrayList<Node>();
var nodeSql = new Sql<>(Node.class).where(rootNode)
    .recursive(new Sql<>(Node.class, "node").where("{node.parentId}={W1.id}"));
Transaction.execute(conn ->
    new Sql<>(Node.class)
        .with(nodeSql)
        .from(nodeSql)
        .connection(conn)
        .select(nodes::add)
);
----

[source,groovy]
.Groovy[small]##での例##
----
List<Node> nodes = []
def nodeSql = new Sql<>(Node).where(rootNode)
    .recursive(new Sql<>(Node, 'node').where('{node.parentId}={W1.id}'))
Transaction.execute {
    new Sql<>(Node)
        .with(nodeSql)
        .from(nodeSql)
        .connection(it)
        .select({nodes << it})
}
----

[source,sql]
.[small]##生成される##SQL - MariaDB, MySQL, PostgreSQL, SQLite
----
WITH RECURSIVE W1(id, parentId, name) AS (
  SELECT id, parentId, name FROM Node WHERE id=1
  UNION ALL
  SELECT node.id node_id, node.parentId node_parentId, node.name node_name
    FROM Node node,W1
    WHERE node.parentId=W1.id
)
SELECT id, parentId, name FROM W1
----

[source,sql]
.[small]##生成される##SQL - DB2, Oracle, SQL Server
----
WITH W1(id, parentId, name) AS (
  SELECT id, parentId, name FROM Node WHERE id=1
  UNION ALL
  SELECT node.id node_id, node.parentId node_parentId, node.name node_name
    FROM Node node,W1
    WHERE node.parentId=W1.id
)
SELECT id, parentId, name FROM W1
----

[[ExecuteSQL-insert]]

<<TOC_,目次へ>>

==== 5-2. INSERT

[[ExecuteSQL-insert-1]]

==== 5-2-1. INSERT 1行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Contact)
        .connection(it)
        .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
}
----

[source,sql]
.[small]##生成される##SQL - DB2, MariaDB, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact
  (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', DATE'2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.[small]##生成される##SQL - SQLite
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', '2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.[small]##生成される##SQL - SQLServer
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', CAST('2001-01-01' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-insert-N]]

<<TOC_,目次へ>>

==== 5-2-2. INSERT 複数行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(Arrays.asList(
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ))
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Contact)
        .connection(it)
        .insert([
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ])
}
----

[source,sql]
.[small]##生成される##SQL - DB2, MariaDB, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', DATE'2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', DATE'2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.[small]##生成される##SQL - SQLite
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', '2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', '2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.[small]##生成される##SQL - SQLServer
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', CAST('2001-01-02' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', CAST('2001-01-03' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-update]]

<<TOC_,目次へ>>

==== 5-3. UPDATE

[[ExecuteSQL-update-1]]

==== 5-3-1. UPDATE 1行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact -> {
            contact.firstName = "Akiyo";
            new Sql<>(Contact.class)
                .connection(conn)
                .update(contact);
        })
);
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {Contact contact ->
            contact.firstName = 'Akiyo'
            new Sql<>(Contact)
                .connection(it)
                .update(contact)
        }
}
----

[source,sql]
.[small]##生成される##SQL - DB2, MariaDB, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.[small]##生成される##SQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.[small]##生成される##SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[[ExecuteSQL-update-N]]

<<TOC_,目次へ>>

==== 5-3-2. UPDATE 複数行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn -> {
    var contacts = new ArrayList<Contact>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contact -> {
            contact.lastName = "Apfel";
            contacts.add(contact);
        });
    new Sql<>(Contact.class)
        .connection(conn)
        .update(contacts);
});
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({Contact contact ->
            contact.lastName = 'Apfel'
            contacts << contact
        })
    new Sql<>(Contact)
        .connection(it)
        .update(contacts)
}
----

[source,sql]
.[small]##生成される##SQL - DB2, MariaDB, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=DATE'2001-01-02', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday=DATE'2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.[small]##生成される##SQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday='2001-01-02', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday='2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.[small]##生成される##SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=CAST('2001-01-02' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday=CAST('2001-01-03' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[[ExecuteSQL-update-Condition]]

<<TOC_,目次へ>>

==== 5-3-3. UPDATE 指定条件, カラム選択

[source,java]
.Java[small]##での例##
----
var contact = new Contact();
contact.lastName = "Pomme";
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apfel")
        .columns("lastName")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy[small]##での例##
----
def contact = new Contact()
contact.lastName = 'Pomme'
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apfel')
        .columns('lastName')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.[small]##生成される##SQL
----
UPDATE Contact SET lastName='Pomme' WHERE lastName='Apfel'
----

[[ExecuteSQL-update-all]]

<<TOC_,目次へ>>

==== 5-3-4. UPDATE 全行

[source,java]
.Java[small]##での例##
----
var contact = new Contact();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition.ALL)
        .columns("birthday")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy[small]##での例##
----
def contact = new Contact()
Transaction.execute {
    new Sql<>(Contact)
        .where(Condition.ALL)
        .columns('birthday')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.[small]##生成される##SQL
----
UPDATE Contact SET birthday=NULL
----

[[ExecuteSQL-delete]]

<<TOC_,目次へ>>

==== 5-4. DELETE

[[ExecuteSQL-delete-1]]

==== 5-4-1. DELETE 1行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact ->
            new Sql<>(Contact.class)
                .connection(conn)
                .delete(contact))
);
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {contact ->
            new Sql<>(Contact)
                .connection(it)
                .delete(contact)
        }
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
DELETE FROM Contact WHERE id=1
----

[[ExecuteSQL-delete-N]]

<<TOC_,目次へ>>

==== 5-4-2. DELETE 複数行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn -> {
    var contacts = new ArrayList<Contact>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Pomme")
        .connection(conn)
        .select(contacts::add);
    new Sql<>(Contact.class)
        .connection(conn)
        .delete(contacts);
});
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Pomme')
        .connection(it)
        .select({contacts << it})
    new Sql<>(Contact)
        .connection(it)
        .delete(contacts)
}
----

[source,sql]
.[small]##生成される##SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Pomme'
DELETE FROM Contact WHERE id=2
DELETE FROM Contact WHERE id=3
----

[[ExecuteSQL-delete-Condition]]

<<TOC_,目次へ>>

==== 5-4-3. DELETE 指定条件

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Orange")
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Orange')
        .connection(it)
        .delete()
}
----

[source,sql]
.[small]##生成される##SQL
----
DELETE FROM Contact WHERE lastName='Orange'
----

[[ExecuteSQL-delete-all]]

<<TOC_,目次へ>>

==== 5-4-4. DELETE 全行

[source,java]
.Java[small]##での例##
----
Transaction.execute(conn ->
    new Sql<>(Phone.class)
        .where(Condition.ALL)
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy[small]##での例##
----
Transaction.execute {
    new Sql<>(Phone)
        .where(Condition.ALL)
        .connection(it)
        .delete()
}
----

[source,sql]
.[small]##生成される##SQL
----
DELETE FROM Phone
----

[[Expression]]

<<TOC_,目次へ>>

=== 6. 式の変換処理

SQL を生成する時に、以下の文字列を式として評価し、変換処理を行います。

* `@Select`, `@Insert`, ``@Update``アノテーションの値

* `@SelectProperty`, `@InsertProperty`, ``@UpdateProperty``アノテーションの ``expression``の値

* `Sql` クラスの以下のメソッドの引数
** `where(String content, Object... arguments)`
** `where(String content, Sql<SE> subSql)`
** `where(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<SE> subSql)`
** `and(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<SE> subSql)`
** `or(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `groupBy(String content, Object... arguments)`
** `having(String content, Object... arguments)`
** `having(String content, Sql<SE> subSql)`
** `having(Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `orderBy(String content, Object... arguments)`

* `Condition` インターフェースの以下のメソッドの引数
** `of(String content, Object... arguments)`
** `of(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `of(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `and(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `or(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(v3.1.0~)_#

* `Expression` クラスの以下のコンストラクタの引数
** `Expression(String content, Object... arguments)`

式の変換には以下があります。

[options="header", width="80%"]
|===
|書式|変換内容
|`{}`     |出現順に``arguments``の要素
|`{xxx}`  |``xxx``プロパティに関連するカラム名
|`{A.xxx}`|`"A."` + ``xxx``プロパティに関連するカラム名(`A` はテーブル別名)
|`{A_xxx}`|テーブル別名``A``と``xxx``プロパティに関連するカラム別名
|`{#xxx}` |`Sql` オブジェクトに設定されたエンティティ(または``Sql#insert``, ``Sql#update``メソッドのエンティティ引数)の``xxx``プロパティの値
|===

[[DateTime]]

<<TOC_,目次へ>>


=== 7. 日時型おけるJava型とカラム型の対応

[[DateTime-DB2]]

===== 7.1 DB2

[options="header", width="65%", cols=",^,^,^,"]
|===
|                          |`DATE`|`TIME`|`TIMESTAMP(9)`|
|`java.util.Date`          |✓     |      |              |
|`java.sql.Date`           |✓     |      |              |
|`java.sql.Time`           |      |✓ (秒)|              |
|`java.sql.Timestamp`      |✓     |      |✓ (10^9^ 秒)  |
|`java.time.LocalDate`     |      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (秒)|              |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |      |✓ (10^9^ 秒)  |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |      |              |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |      |              |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-MariaDB_MySQL]]

===== 7.2 MariaDB, MySQL

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME`      |`DATETIME`  |`TIMESTAMP` |
|`java.util.Date`          |✓     |            |            |            |
|`java.sql.Date`           |✓     |            |            |            |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|            |            |
|`java.sql.Timestamp`      |✓     |            |✓ (10^6^ 秒)|✓ (10^6^ 秒)|
|`java.time.LocalDate`     |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^6^ 秒)|            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^6^ 秒)|✓ (10^6^ 秒)|[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |            |            |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-Oracle]]

===== 7.3 Oracle

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIMESTAMP(9)`|`TIMESTAMP(9) WITH TIME ZONE`|`TIMESTAMP(9) WITH LOCAL TIME ZONE`|
|`java.util.Date`          |✓     |              |                             |                                   |
|`java.sql.Date`           |✓     |              |                             |                                   |
|`java.sql.Time`           |✓ (秒)|              |                             |                                   |
|`java.sql.Timestamp`      |✓ (秒)|✓ (10^9^ 秒)  |                             |✓ (10^9^ 秒)                       |
|`java.time.LocalDate`     |✓ (秒)|              |                             |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |✓ (秒)|              |                             |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |✓ (秒)|✓ (10^9^ 秒)  |                             |✓ (10^9^ 秒)                       |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |              |✓ (10^9^ 秒)                 |                                   |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-PostgreSQL]]

===== 7.4 PostgreSQL

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(6)`   |`TIMESTAMP(6)`|`TIMESTAMP(6) WITH TIME ZONE`|
|`java.util.Date`          |✓     |            |              |                             |
|`java.sql.Date`           |✓     |            |              |                             |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|              |                             |
|`java.sql.Timestamp`      |✓     |            |✓ (10^6^ 秒)  |                             |
|`java.time.LocalDate`     |      |            |              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^6^ 秒)|              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^6^ 秒)  |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |              |✓ (10^6^ 秒)                 |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |              |                             |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |              |✓ (10^6^ 秒)                 |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-SQLite]]

===== 7.5 SQLite

[options="header", width="40%", cols=",^,"]
|===
|                          |`DATE`, `TIME`, `DATETIME`, `TEXT`|
|`java.util.Date`          |✓                                 |
|`java.sql.Date`           |✓                                 |
|`java.sql.Time`           |✓ (10^3^ 秒)                      |
|`java.sql.Timestamp`      |✓ (10^9^ 秒)                      |
|`java.time.LocalDate`     |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |✓ (10^9^ 秒)                      |[small fuchsia]#_v3.0.0~_#
|===

[[DateTime-SQLServer]]

===== 7.6 SQL Server

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(7)`   |`DATETIME2(7)`|`DATETIMEOFFSET(7)`|
|`java.util.Date`          |✓     |            |              |                   |
|`java.sql.Date`           |✓     |            |              |                   |
|`java.sql.Time`           |      |✓ (10^3^ 秒)|              |                   |
|`java.sql.Timestamp`      |✓     |            |✓ (10^7^ 秒)  |                   |
|`java.time.LocalDate`     |      |            |              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalTime`     |      |✓ (10^3^ 秒)|              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.LocalDateTime` |      |            |✓ (10^7^ 秒)  |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.OffsetDateTime`|      |            |              |✓ (10^7^ 秒)       |[small fuchsia]#_v3.0.0~_#
|`java.time.ZonedDateTime` |      |            |              |                   |[small fuchsia]#_v3.0.0~_#
|`java.time.Instant`       |      |            |              |✓ (10^7^ 秒)       |[small fuchsia]#_v3.0.0~_#
|===

<<TOC_,目次へ>>

[gray]#_(C) 2015 Masato Kokubo_#
